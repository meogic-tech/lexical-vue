{"version":3,"sources":["../src/index.ts","../src/composables/useCanShowPlaceholder.ts","../src/composables/useMounted.ts","../src/composables/useCharacterLimit.ts","../src/composables/useDecorators.ts","../src/composables/useLexicalComposer.ts","../src/composables/inject.ts","../src/composables/useHistory.ts","../src/composables/useLexicalIsTextContentEmpty.ts","../src/composables/useLexicalNodeSelection.ts","../src/composables/useLexicalTextEntity.ts","../src/composables/useList.ts","../src/composables/usePlainTextSetup.ts","../src/composables/useRichTextSetup.ts","../src/composables/useEffect.ts","../src/composables/useYjsCollaboration.ts","../src/composables/useLexicalCommandsLog.ts","../src/components/LexicalDecoratedTeleports.ts","../src/components/Users/wing/Develop/lexical-vue-for-meogic/src/components/LexicalContentEditable.vue","../src/components/Users/wing/Develop/lexical-vue-for-meogic/src/components/LexicalPlainTextPlugin.vue","../src/components/Users/wing/Develop/lexical-vue-for-meogic/src/components/LexicalComposer.vue","../src/components/Users/wing/Develop/lexical-vue-for-meogic/src/components/LexicalOnChangePlugin.vue","../src/components/Users/wing/Develop/lexical-vue-for-meogic/src/components/LexicalHistoryPlugin.vue","../src/components/Users/wing/Develop/lexical-vue-for-meogic/src/components/LexicalTreeViewPlugin.vue","../src/components/Users/wing/Develop/lexical-vue-for-meogic/src/components/LexicalAutoFocusPlugin.vue","../src/components/Users/wing/Develop/lexical-vue-for-meogic/src/components/LexicalRichTextPlugin.vue","../src/components/Users/wing/Develop/lexical-vue-for-meogic/src/components/LexicalListPlugin.vue","../src/components/Users/wing/Develop/lexical-vue-for-meogic/src/components/LexicalLinkPlugin.vue","../src/components/Users/wing/Develop/lexical-vue-for-meogic/src/components/LexicalTablePlugin.vue","../src/components/Users/wing/Develop/lexical-vue-for-meogic/src/components/LexicalClearEditorPlugin.vue","../src/components/Users/wing/Develop/lexical-vue-for-meogic/src/components/LexicalCharacterLimitPlugin.vue","../src/components/Users/wing/Develop/lexical-vue-for-meogic/src/components/LexicalAutoScrollPlugin.vue","../src/components/Users/wing/Develop/lexical-vue-for-meogic/src/components/LexicalHashtagPlugin.vue","../src/components/LexicalDecoratorBlockNode.ts","../src/components/Users/wing/Develop/lexical-vue-for-meogic/src/components/LexicalBlockWithAlignableContents.vue","../src/components/Users/wing/Develop/lexical-vue-for-meogic/src/components/LexicalCheckListPlugin.vue","../src/composables/listenerManager.ts","../src/components/Users/wing/Develop/lexical-vue-for-meogic/src/components/LexicalMarkdownShortcutPlugin.vue","../src/components/Users/wing/Develop/lexical-vue-for-meogic/src/components/LexicalTabIndentationPlugin.vue","../src/components/Users/wing/Develop/lexical-vue-for-meogic/src/components/LexicalCollaborationPlugin.vue","../src/composables/useCollaborationContext.ts","../src/components/Users/wing/Develop/lexical-vue-for-meogic/src/components/LexicalClickableLinkPlugin.vue","../src/components/Users/wing/Develop/lexical-vue-for-meogic/src/components/LexicalContextMenuPlugin.vue","../src/components/LexicalMenu/shared.ts","../src/components/LexicalMenu/Users/wing/Develop/lexical-vue-for-meogic/src/components/LexicalMenu/index.vue","../src/components/Users/wing/Develop/lexical-vue-for-meogic/src/components/LexicalNodeMenuPlugin.vue","../src/components/LexicalAutoEmbedPlugin/Users/wing/Develop/lexical-vue-for-meogic/src/components/LexicalAutoEmbedPlugin/index.vue","../src/components/LexicalAutoEmbedPlugin/shared.ts","../src/components/LexicalAutoLinkPlugin/shared.ts","../src/components/LexicalAutoLinkPlugin/Users/wing/Develop/lexical-vue-for-meogic/src/components/LexicalAutoLinkPlugin/index.vue","../src/components/LexicalTypeaheadMenuPlugin/Users/wing/Develop/lexical-vue-for-meogic/src/components/LexicalTypeaheadMenuPlugin/index.vue","../src/components/LexicalTypeaheadMenuPlugin/shared.ts"],"sourcesContent":["export * from './composables'\nexport * from './components'\n","import { readonly, ref } from 'vue'\nimport { $canShowPlaceholderCurry } from '@lexical/text'\nimport type { LexicalEditor } from 'lexical'\nimport { mergeRegister } from '@lexical/utils'\nimport { useMounted } from './useMounted'\n\nfunction canShowPlaceholderFromCurrentEditorState(\n  editor: LexicalEditor,\n): boolean {\n  const currentCanShowPlaceholder = editor\n    .getEditorState()\n    .read($canShowPlaceholderCurry(editor.isComposing()))\n\n  return currentCanShowPlaceholder\n}\n\nexport function useCanShowPlaceholder(editor: LexicalEditor) {\n  const initialState = editor\n    .getEditorState()\n    .read($canShowPlaceholderCurry(editor.isComposing()))\n\n  const canShowPlaceholder = ref(initialState)\n\n  function resetCanShowPlaceholder() {\n    const currentCanShowPlaceholder\n    = canShowPlaceholderFromCurrentEditorState(editor)\n    canShowPlaceholder.value = currentCanShowPlaceholder\n  }\n\n  useMounted(() => {\n    return mergeRegister(\n      editor.registerUpdateListener(() => {\n        resetCanShowPlaceholder()\n      }),\n      editor.registerEditableListener(() => {\n        resetCanShowPlaceholder()\n      }),\n    )\n  })\n\n  return readonly(canShowPlaceholder)\n}\n","import { onMounted, onUnmounted } from 'vue'\n\n/**\n * @internal\n */\nexport function useMounted(cb: () => undefined | (() => any)) {\n  let unregister: (() => void) | undefined\n\n  onMounted(() => {\n    unregister = cb()\n  })\n\n  onUnmounted(() => {\n    unregister?.()\n  })\n}\n","import type { LexicalEditor, LexicalNode } from 'lexical'\n\nimport {\n  $createOverflowNode,\n  $isOverflowNode,\n  OverflowNode,\n} from '@lexical/overflow'\nimport { $rootTextContent } from '@lexical/text'\nimport { $dfs, mergeRegister } from '@lexical/utils'\nimport {\n  $getSelection,\n  $isLeafNode,\n  $isRangeSelection,\n  $isTextNode,\n  $setSelection,\n} from 'lexical'\nimport invariant from 'tiny-invariant'\n\nimport { useMounted } from './useMounted'\n\ninterface OptionalProps {\n  remainingCharacters?: (characters: number) => void\n  strlen?: (input: string) => number\n}\n\nexport function useCharacterLimit(\n  editor: LexicalEditor,\n  maxCharacters: number,\n  optional: OptionalProps = Object.freeze({}),\n) {\n  const {\n    strlen = input => input.length, // UTF-16\n    remainingCharacters = (_characters) => {},\n  } = optional\n\n  useMounted(() => {\n    if (!editor.hasNodes([OverflowNode])) {\n      invariant(\n        false,\n        'useCharacterLimit: OverflowNode not registered on editor',\n      )\n    }\n\n    let text = editor.getEditorState().read($rootTextContent)\n    let lastComputedTextLength = 0\n\n    return mergeRegister(\n      editor.registerTextContentListener((currentText: string) => {\n        text = currentText\n      }),\n      editor.registerUpdateListener(({ dirtyLeaves }) => {\n        const isComposing = editor.isComposing()\n        const hasDirtyLeaves = dirtyLeaves.size > 0\n        if (isComposing || !hasDirtyLeaves)\n          return\n\n        const textLength = strlen(text)\n        const textLengthAboveThreshold\n          = textLength > maxCharacters\n          || (lastComputedTextLength !== null\n          && lastComputedTextLength > maxCharacters)\n        const diff = maxCharacters - textLength\n        remainingCharacters(diff)\n        if (lastComputedTextLength === null || textLengthAboveThreshold) {\n          const offset = findOffset(text, maxCharacters, strlen)\n          editor.update(\n            () => {\n              $wrapOverflowedNodes(offset)\n            },\n            {\n              tag: 'history-merge',\n            },\n          )\n        }\n        lastComputedTextLength = textLength\n      }),\n    )\n  })\n}\n\nfunction findOffset(\n  text: string,\n  maxCharacters: number,\n  strlen: (input: string) => number,\n): number {\n  const Segmenter = Intl.Segmenter\n  let offsetUtf16 = 0\n  let offset = 0\n\n  if (typeof Segmenter === 'function') {\n    const segmenter = new Segmenter()\n    const graphemes = segmenter.segment(text)\n\n    for (const { segment: grapheme } of graphemes) {\n      const nextOffset = offset + strlen(grapheme)\n\n      if (nextOffset > maxCharacters)\n        break\n\n      offset = nextOffset\n      offsetUtf16 += grapheme.length\n    }\n  }\n  else {\n    const codepoints = Array.from(text)\n    const codepointsLength = codepoints.length\n\n    for (let i = 0; i < codepointsLength; i++) {\n      const codepoint = codepoints[i]\n      const nextOffset = offset + strlen(codepoint)\n\n      if (nextOffset > maxCharacters)\n        break\n\n      offset = nextOffset\n      offsetUtf16 += codepoint.length\n    }\n  }\n\n  return offsetUtf16\n}\n\nfunction $wrapOverflowedNodes(offset: number): void {\n  const dfsNodes = $dfs()\n  const dfsNodesLength = dfsNodes.length\n  let accumulatedLength = 0\n\n  for (let i = 0; i < dfsNodesLength; i += 1) {\n    const { node } = dfsNodes[i]\n\n    if ($isOverflowNode(node)) {\n      const previousLength = accumulatedLength\n      const nextLength = accumulatedLength + node.getTextContentSize()\n\n      if (nextLength <= offset) {\n        const parent = node.getParent()\n        const previousSibling = node.getPreviousSibling()\n        const nextSibling = node.getNextSibling()\n        $unwrapNode(node)\n        const selection = $getSelection()\n\n        // Restore selection when the overflow children are removed\n        if (\n          $isRangeSelection(selection)\n          && (!selection.anchor.getNode().isAttached()\n          || !selection.focus.getNode().isAttached())\n        ) {\n          if ($isTextNode(previousSibling))\n            previousSibling.select()\n          else if ($isTextNode(nextSibling))\n            nextSibling.select()\n          else if (parent !== null)\n            parent.select()\n        }\n      }\n      else if (previousLength < offset) {\n        const descendant = node.getFirstDescendant()\n        const descendantLength\n          = descendant !== null ? descendant.getTextContentSize() : 0\n        const previousPlusDescendantLength = previousLength + descendantLength\n        // For simple text we can redimension the overflow into a smaller and more accurate\n        // container\n        const firstDescendantIsSimpleText\n          = $isTextNode(descendant) && descendant.isSimpleText()\n        const firstDescendantDoesNotOverflow\n          = previousPlusDescendantLength <= offset\n\n        if (firstDescendantIsSimpleText || firstDescendantDoesNotOverflow)\n          $unwrapNode(node)\n      }\n    }\n    else if ($isLeafNode(node)) {\n      const previousAccumulatedLength = accumulatedLength\n      accumulatedLength += node.getTextContentSize()\n\n      if (accumulatedLength > offset && !$isOverflowNode(node.getParent())) {\n        const previousSelection = $getSelection()\n        let overflowNode\n\n        // For simple text we can improve the limit accuracy by splitting the TextNode\n        // on the split point\n        if (\n          previousAccumulatedLength < offset\n          && $isTextNode(node)\n          && node.isSimpleText()\n        ) {\n          const [, overflowedText] = node.splitText(\n            offset - previousAccumulatedLength,\n          )\n          overflowNode = $wrapNode(overflowedText)\n        }\n        else {\n          overflowNode = $wrapNode(node)\n        }\n\n        if (previousSelection !== null)\n          $setSelection(previousSelection)\n\n        mergePrevious(overflowNode)\n      }\n    }\n  }\n}\n\nfunction $wrapNode(node: LexicalNode): OverflowNode {\n  const overflowNode = $createOverflowNode()\n  node.insertBefore(overflowNode)\n  overflowNode.append(node)\n  return overflowNode\n}\n\nfunction $unwrapNode(node: OverflowNode): LexicalNode | null {\n  const children = node.getChildren()\n  const childrenLength = children.length\n\n  for (let i = 0; i < childrenLength; i++)\n    node.insertBefore(children[i])\n\n  node.remove()\n  return childrenLength > 0 ? children[childrenLength - 1] : null\n}\n\nexport function mergePrevious(overflowNode: OverflowNode): void {\n  const previousNode = overflowNode.getPreviousSibling()\n\n  if (!$isOverflowNode(previousNode))\n    return\n\n  const firstChild = overflowNode.getFirstChild()\n  const previousNodeChildren = previousNode.getChildren()\n  const previousNodeChildrenLength = previousNodeChildren.length\n\n  if (firstChild === null) {\n    overflowNode.append(...previousNodeChildren)\n  }\n  else {\n    for (let i = 0; i < previousNodeChildrenLength; i++)\n      firstChild.insertBefore(previousNodeChildren[i])\n  }\n\n  const selection = $getSelection()\n\n  if ($isRangeSelection(selection)) {\n    const anchor = selection.anchor\n    const anchorNode = anchor.getNode()\n    const focus = selection.focus\n    const focusNode = anchor.getNode()\n\n    if (anchorNode.is(previousNode)) {\n      anchor.set(overflowNode.getKey(), anchor.offset, 'element')\n    }\n    else if (anchorNode.is(overflowNode)) {\n      anchor.set(\n        overflowNode.getKey(),\n        previousNodeChildrenLength + anchor.offset,\n        'element',\n      )\n    }\n\n    if (focusNode.is(previousNode)) {\n      focus.set(overflowNode.getKey(), focus.offset, 'element')\n    }\n    else if (focusNode.is(overflowNode)) {\n      focus.set(\n        overflowNode.getKey(),\n        previousNodeChildrenLength + focus.offset,\n        'element',\n      )\n    }\n  }\n\n  previousNode.remove()\n}\n","import type { LexicalEditor } from 'lexical'\nimport type { DefineComponent } from 'vue'\nimport { Teleport, computed, h, shallowRef, unref } from 'vue'\nimport { useMounted } from './useMounted'\n\nexport function useDecorators(editor: LexicalEditor) {\n  const decorators = shallowRef<Record<string, DefineComponent>>(editor.getDecorators())\n\n  useMounted(() => {\n    return editor.registerDecoratorListener((nextDecorators) => {\n      decorators.value = nextDecorators as Record<string, DefineComponent>\n    })\n  })\n\n  // Return decorators defined as Vue Teleports\n  return computed(() => {\n    const decoratedTeleports = []\n    const decoratorKeys = Object.keys(unref(decorators))\n    for (let i = 0; i < decoratorKeys.length; i++) {\n      const nodeKey = decoratorKeys[i]\n      const vueDecorator = decorators.value[nodeKey]\n      const element = editor.getElementByKey(nodeKey)\n      if (element !== null) {\n        decoratedTeleports.push(\n          h(Teleport, {\n            to: element,\n          }, vueDecorator),\n        )\n      }\n    }\n\n    return decoratedTeleports\n  })\n}\n","import { inject } from 'vue'\nimport invariant from 'tiny-invariant'\nimport type { LexicalEditor } from 'lexical'\nimport { LexicalEditorProviderKey } from './inject'\n\nexport function useLexicalComposer() {\n  const editor = inject<LexicalEditor>(LexicalEditorProviderKey)\n\n  if (!editor) {\n    invariant(\n      false,\n      'useLexicalComposer: cannot find a LexicalComposer',\n    )\n  }\n\n  return editor\n}\n\n/**\n * @deprecated use `useLexicalComposer` instead\n */\nexport const useEditor = useLexicalComposer\n","export const LexicalEditorProviderKey = 'LexicalEditorProviderKey'\n","import type { HistoryState } from '@lexical/history'\nimport type { LexicalEditor } from 'lexical'\nimport { type MaybeRef, computed, unref, watchEffect } from 'vue'\n\nimport { createEmptyHistoryState, registerHistory } from '@lexical/history'\n\nexport function useHistory(\n  editor: MaybeRef<LexicalEditor>,\n  externalHistoryState?: MaybeRef<HistoryState>,\n  delay?: MaybeRef<number>,\n) {\n  const historyState = computed<HistoryState>(\n    () => unref(externalHistoryState) || createEmptyHistoryState(),\n  )\n\n  watchEffect((onInvalidate) => {\n    const unregisterListener = registerHistory(unref(editor), historyState.value, unref(delay) || 1000)\n\n    onInvalidate(unregisterListener)\n  })\n}\n","import { readonly, ref } from 'vue'\nimport { $isRootTextContentEmptyCurry } from '@lexical/text'\nimport type { LexicalEditor } from 'lexical'\nimport { useMounted } from './useMounted'\n\nexport function useLexicalIsTextContentEmpty(editor: LexicalEditor, trim?: boolean) {\n  const isEmpty = ref(\n    editor\n      .getEditorState()\n      .read($isRootTextContentEmptyCurry(editor.isComposing(), trim)),\n  )\n\n  useMounted(() => {\n    return editor.registerUpdateListener(({ editorState }) => {\n      const isComposing = editor.isComposing()\n      isEmpty.value = editorState.read(\n        $isRootTextContentEmptyCurry(isComposing, trim),\n      )\n    })\n  })\n\n  return readonly(isEmpty)\n}\n","import type { LexicalEditor, NodeKey } from 'lexical'\n\nimport {\n  $createNodeSelection,\n  $getNodeByKey,\n  $getSelection,\n  $isNodeSelection,\n  $setSelection,\n} from 'lexical'\nimport { type MaybeRef, readonly, ref, unref, watchEffect } from 'vue'\nimport { useLexicalComposer } from './useLexicalComposer'\n\nfunction isNodeSelected(editor: LexicalEditor, key: NodeKey): boolean {\n  return editor.getEditorState().read(() => {\n    const node = $getNodeByKey(key)\n    if (node === null)\n      return false\n\n    return node.isSelected()\n  })\n}\n\nexport function useLexicalNodeSelection(\n  key: MaybeRef<NodeKey>,\n) {\n  const editor = useLexicalComposer()\n  const isSelected = ref(isNodeSelected(editor, unref(key)))\n\n  watchEffect((onInvalidate) => {\n    const unregisterListener = editor.registerUpdateListener(() => {\n      isSelected.value = isNodeSelected(editor, unref(key))\n    })\n\n    onInvalidate(() => {\n      unregisterListener()\n    })\n  })\n\n  const setSelected = (selected: boolean) => {\n    editor.update(() => {\n      let selection = $getSelection()\n\n      if (!$isNodeSelection(selection)) {\n        selection = $createNodeSelection()\n        $setSelection(selection)\n      }\n      if ($isNodeSelection(selection)) {\n        if (selected)\n          selection.add(unref(key))\n        else\n          selection.delete(unref(key))\n      }\n    })\n  }\n\n  const clearSelection = () => {\n    editor.update(() => {\n      const selection = $getSelection()\n      if ($isNodeSelection(selection))\n        (selection).clear()\n    })\n  }\n\n  return {\n    isSelected: readonly(isSelected),\n    setSelected,\n    clearSelection,\n  }\n}\n","import type { EntityMatch } from '@lexical/text'\nimport type { Klass, TextNode } from 'lexical'\n\nimport { registerLexicalTextEntity } from '@lexical/text'\nimport { mergeRegister } from '@lexical/utils'\nimport { useLexicalComposer } from './useLexicalComposer'\nimport { useMounted } from './useMounted'\n\nexport function useLexicalTextEntity<T extends TextNode>(\n  getMatch: (text: string) => null | EntityMatch,\n  targetNode: Klass<T>,\n  createNode: (textNode: TextNode) => T,\n): void {\n  const editor = useLexicalComposer()\n\n  useMounted(() => {\n    return mergeRegister(\n      ...registerLexicalTextEntity(editor, getMatch, targetNode, createNode),\n    )\n  })\n}\n","import type { LexicalEditor } from 'lexical'\n\nimport {\n  $handleListInsertParagraph,\n  INSERT_ORDERED_LIST_COMMAND,\n  INSERT_UNORDERED_LIST_COMMAND,\n  REMOVE_LIST_COMMAND,\n  insertList,\n  removeList,\n} from '@lexical/list'\nimport { mergeRegister } from '@lexical/utils'\nimport {\n  COMMAND_PRIORITY_LOW,\n  INSERT_PARAGRAPH_COMMAND,\n} from 'lexical'\nimport { useMounted } from './useMounted'\n\nexport function useList(editor: LexicalEditor) {\n  useMounted(() => {\n    return mergeRegister(\n      editor.registerCommand(\n        INSERT_ORDERED_LIST_COMMAND,\n        () => {\n          insertList(editor, 'number')\n          return true\n        },\n        COMMAND_PRIORITY_LOW,\n      ),\n      editor.registerCommand(\n        INSERT_UNORDERED_LIST_COMMAND,\n        () => {\n          insertList(editor, 'bullet')\n          return true\n        },\n        COMMAND_PRIORITY_LOW,\n      ),\n      editor.registerCommand(\n        REMOVE_LIST_COMMAND,\n        () => {\n          removeList(editor)\n          return true\n        },\n        COMMAND_PRIORITY_LOW,\n      ),\n      editor.registerCommand(\n        INSERT_PARAGRAPH_COMMAND,\n        () => {\n          const hasHandledInsertParagraph = $handleListInsertParagraph()\n\n          if (hasHandledInsertParagraph)\n            return true\n\n          return false\n        },\n        COMMAND_PRIORITY_LOW,\n      ),\n    )\n  })\n}\n","import { registerDragonSupport } from '@lexical/dragon'\nimport { registerPlainText } from '@lexical/plain-text'\nimport { mergeRegister } from '@lexical/utils'\nimport type { LexicalEditor } from 'lexical'\nimport { useMounted } from './useMounted'\n\nexport function usePlainTextSetup(editor: LexicalEditor) {\n  useMounted(() => {\n    return mergeRegister(\n      registerPlainText(editor),\n      registerDragonSupport(editor),\n    )\n  })\n}\n","import { registerDragonSupport } from '@lexical/dragon'\nimport { registerRichText } from '@lexical/rich-text'\nimport { mergeRegister } from '@lexical/utils'\nimport type { LexicalEditor } from 'lexical'\nimport { useMounted } from './useMounted'\n\nexport function useRichTextSetup(editor: LexicalEditor) {\n  useMounted(() => {\n    return mergeRegister(\n      registerRichText(editor),\n      registerDragonSupport(editor),\n    )\n  })\n}\n","import type { WatchOptionsBase } from 'vue'\nimport { watchEffect } from 'vue'\n\n/**\n * @internal\n */\nexport function useEffect(cb: () => (() => any) | undefined, options?: WatchOptionsBase) {\n  watchEffect((onInvalidate) => {\n    const unregister = cb()\n\n    onInvalidate(() => unregister?.())\n  }, {\n    flush: 'post',\n    ...options,\n  })\n}\n","import type { Binding, ExcludedProperties, Provider } from '@lexical/yjs'\nimport type { LexicalEditor } from 'lexical'\n\nimport { mergeRegister } from '@lexical/utils'\nimport {\n  CONNECTED_COMMAND,\n  TOGGLE_CONNECT_COMMAND,\n  createBinding,\n  createUndoManager,\n  initLocalState,\n  setLocalStateFocus,\n  syncCursorPositions,\n  syncLexicalUpdateToYjs,\n  syncYjsChangesToLexical,\n} from '@lexical/yjs'\nimport {\n  $createParagraphNode,\n  $getRoot,\n  $getSelection,\n  BLUR_COMMAND,\n  COMMAND_PRIORITY_EDITOR,\n  FOCUS_COMMAND,\n  REDO_COMMAND,\n  UNDO_COMMAND,\n} from 'lexical'\nimport type { Doc, Transaction, YEvent } from 'yjs'\nimport { UndoManager } from 'yjs'\nimport type { ComputedRef } from 'vue'\nimport { computed, ref, toRaw } from 'vue'\nimport type { InitialEditorStateType } from '../types'\nimport { useEffect } from './useEffect'\n\nexport function useYjsCollaboration(\n  editor: LexicalEditor,\n  id: string,\n  provider: Provider,\n  docMap: Map<string, Doc>,\n  name: string,\n  color: string,\n  shouldBootstrap: boolean,\n  initialEditorState?: InitialEditorStateType,\n  excludedProperties?: ExcludedProperties,\n  awarenessData?: object,\n): ComputedRef<Binding> {\n  const isReloadingDoc = ref(false)\n  const doc = ref(docMap.get(id))\n\n  const binding = computed(() => createBinding(editor, provider, id, toRaw(doc.value), docMap, excludedProperties))\n\n  const connect = () => {\n    provider.connect()\n  }\n\n  const disconnect = () => {\n    try {\n      provider.disconnect()\n    }\n    catch (e) {\n      // Do nothing\n    }\n  }\n\n  useEffect(() => {\n    const { root } = binding.value\n    const { awareness } = provider\n\n    const onStatus = ({ status }: { status: string }) => {\n      editor.dispatchCommand(CONNECTED_COMMAND, status === 'connected')\n    }\n\n    const onSync = (isSynced: boolean) => {\n      if (\n        shouldBootstrap\n        && isSynced\n        && root.isEmpty()\n        && root._xmlText._length === 0\n        && isReloadingDoc.value === false\n      )\n        initializeEditor(editor, initialEditorState)\n\n      isReloadingDoc.value = false\n    }\n\n    const onAwarenessUpdate = () => {\n      syncCursorPositions(binding.value, provider)\n    }\n\n    const onYjsTreeChanges = (\n      // The below `any` type is taken directly from the vendor types for YJS.\n      events: Array<YEvent<any>>,\n      transaction: Transaction,\n    ) => {\n      const origin = transaction.origin\n      if (toRaw(origin) !== binding.value) {\n        const isFromUndoManger = origin instanceof UndoManager\n        syncYjsChangesToLexical(binding.value, provider, events, isFromUndoManger)\n      }\n    }\n\n    initLocalState(\n      provider,\n      name,\n      color,\n      document.activeElement === editor.getRootElement(),\n      awarenessData || {},\n    )\n\n    const onProviderDocReload = (ydoc: Doc) => {\n      clearEditorSkipCollab(editor, binding.value)\n      doc.value = ydoc\n      docMap.set(id, ydoc)\n      isReloadingDoc.value = true\n    }\n\n    provider.on('reload', onProviderDocReload)\n    provider.on('status', onStatus)\n    provider.on('sync', onSync)\n    awareness.on('update', onAwarenessUpdate)\n    // This updates the local editor state when we recieve updates from other clients\n    root.getSharedType().observeDeep(onYjsTreeChanges)\n    const removeListener = editor.registerUpdateListener(\n      ({ prevEditorState, editorState, dirtyLeaves, dirtyElements, normalizedNodes, tags }) => {\n        if (tags.has('skip-collab') === false) {\n          syncLexicalUpdateToYjs(\n            binding.value,\n            provider,\n            prevEditorState,\n            editorState,\n            dirtyElements,\n            dirtyLeaves,\n            normalizedNodes,\n            tags,\n          )\n        }\n      },\n    )\n    connect()\n\n    return () => {\n      if (isReloadingDoc.value === false)\n        disconnect()\n\n      provider.off('sync', onSync)\n      provider.off('status', onStatus)\n      provider.off('reload', onProviderDocReload)\n      awareness.off('update', onAwarenessUpdate)\n      root.getSharedType().unobserveDeep(onYjsTreeChanges)\n      docMap.delete(id)\n      removeListener()\n    }\n  })\n\n  useEffect(() => {\n    return editor.registerCommand(\n      TOGGLE_CONNECT_COMMAND,\n      (payload) => {\n        if (connect !== undefined && disconnect !== undefined) {\n          const shouldConnect = payload\n\n          if (shouldConnect) {\n            // eslint-disable-next-line no-console\n            console.log('Collaboration connected!')\n            connect()\n          }\n          else {\n            // eslint-disable-next-line no-console\n            console.log('Collaboration disconnected!')\n            disconnect()\n          }\n        }\n\n        return true\n      },\n      COMMAND_PRIORITY_EDITOR,\n    )\n  })\n\n  return binding\n}\n\nexport function useYjsFocusTracking(\n  editor: LexicalEditor,\n  provider: Provider,\n  name: string,\n  color: string,\n  awarenessData?: object,\n) {\n  useEffect(() => {\n    return mergeRegister(\n      editor.registerCommand(\n        FOCUS_COMMAND,\n        () => {\n          setLocalStateFocus(provider, name, color, true, awarenessData || {})\n          return false\n        },\n        COMMAND_PRIORITY_EDITOR,\n      ),\n      editor.registerCommand(\n        BLUR_COMMAND,\n        () => {\n          setLocalStateFocus(provider, name, color, false, awarenessData || {})\n          return false\n        },\n        COMMAND_PRIORITY_EDITOR,\n      ),\n    )\n  })\n}\n\nexport function useYjsHistory(editor: LexicalEditor, binding: Binding): () => void {\n  const undoManager = computed(() => createUndoManager(binding, binding.root.getSharedType()))\n\n  useEffect(() => {\n    const undo = () => {\n      undoManager.value.undo()\n    }\n\n    const redo = () => {\n      undoManager.value.redo()\n    }\n\n    return mergeRegister(\n      editor.registerCommand(\n        UNDO_COMMAND,\n        () => {\n          undo()\n          return true\n        },\n        COMMAND_PRIORITY_EDITOR,\n      ),\n      editor.registerCommand(\n        REDO_COMMAND,\n        () => {\n          redo()\n          return true\n        },\n        COMMAND_PRIORITY_EDITOR,\n      ),\n    )\n  })\n  const clearHistory = () => {\n    undoManager.value.clear()\n  }\n  return clearHistory\n}\n\nfunction initializeEditor(\n  editor: LexicalEditor,\n  initialEditorState?: InitialEditorStateType,\n): void {\n  editor.update(\n    () => {\n      const root = $getRoot()\n\n      if (root.isEmpty()) {\n        if (initialEditorState) {\n          switch (typeof initialEditorState) {\n            case 'string': {\n              const parsedEditorState = editor.parseEditorState(initialEditorState)\n              editor.setEditorState(parsedEditorState, { tag: 'history-merge' })\n              break\n            }\n            case 'object': {\n              editor.setEditorState(initialEditorState, { tag: 'history-merge' })\n              break\n            }\n            case 'function': {\n              editor.update(\n                () => {\n                  const root1 = $getRoot()\n                  if (root1.isEmpty())\n                    initialEditorState(editor)\n                },\n                { tag: 'history-merge' },\n              )\n              break\n            }\n          }\n        }\n        else {\n          const paragraph = $createParagraphNode()\n          root.append(paragraph)\n          const { activeElement } = document\n\n          if (\n            $getSelection() !== null\n            || (activeElement !== null && activeElement === editor.getRootElement())\n          )\n            paragraph.select()\n        }\n      }\n    },\n    {\n      tag: 'history-merge',\n    },\n  )\n}\n\nfunction clearEditorSkipCollab(editor: LexicalEditor, binding: Binding) {\n  // reset editor state\n  editor.update(\n    () => {\n      const root = $getRoot()\n      root.clear()\n      root.select()\n    },\n    {\n      tag: 'skip-collab',\n    },\n  )\n\n  if (binding.cursors == null)\n    return\n\n  const cursors = binding.cursors\n\n  if (cursors == null)\n    return\n\n  const cursorsContainer = binding.cursorsContainer\n\n  if (cursorsContainer == null)\n    return\n\n  // reset cursors in dom\n  const cursorsArr = Array.from(cursors.values())\n\n  for (let i = 0; i < cursorsArr.length; i++) {\n    const cursor = cursorsArr[i]\n    const selection = cursor.selection\n\n    if (selection && selection.selections !== null) {\n      const selections = selection.selections\n\n      for (let j = 0; j < selections.length; j++) cursorsContainer.removeChild(selections[i])\n    }\n  }\n}\n","import { COMMAND_PRIORITY_HIGH, type LexicalCommand, type LexicalEditor } from 'lexical'\nimport { readonly, ref } from 'vue'\nimport { useMounted } from './useMounted'\n\nexport function useLexicalCommandsLog(\n  editor: LexicalEditor,\n) {\n  const loggedCommands = ref<Array<LexicalCommand<unknown> & { payload: unknown }>>([])\n\n  useMounted(() => {\n    const unregisterCommandListeners = new Set<() => void>()\n\n    for (const [command] of editor._commands) {\n      unregisterCommandListeners.add(\n        editor.registerCommand(\n          command,\n          (payload) => {\n            loggedCommands.value = [\n              ...loggedCommands.value,\n              {\n                payload,\n                type: command.type ? command.type : 'UNKNOWN',\n              },\n            ]\n\n            if (loggedCommands.value.length > 10)\n              loggedCommands.value.shift()\n\n            return false\n          },\n          COMMAND_PRIORITY_HIGH,\n        ),\n      )\n    }\n\n    return () => {\n      unregisterCommandListeners.forEach(unregister => unregister())\n    }\n  })\n\n  return readonly(loggedCommands)\n}\n","import { defineComponent } from 'vue'\nimport { useDecorators, useLexicalComposer } from '../composables'\n\nexport default defineComponent({\n  name: 'LexicalDecoratedTeleports',\n  setup() {\n    const editor = useLexicalComposer()\n    const decorators = useDecorators(editor)\n\n    return () => decorators.value\n  },\n})\n","<script setup lang=\"ts\">\nimport { ref } from 'vue'\nimport { useLexicalComposer } from '../composables'\nimport { useMounted } from '../composables/useMounted'\n\nwithDefaults(defineProps<{\n  ariaActivedescendant?: string\n  ariaAutocomplete?: 'none' | 'inline' | 'list' | 'both'\n  ariaControls?: string\n  ariaDescribedby?: string\n  ariaExpanded?: boolean\n  ariaLabel?: string\n  ariaLabelledby?: string\n  ariaMultiline?: boolean\n  ariaOwns?: string\n  ariaRequired?: boolean\n  autoCapitalize?: boolean\n  autoComplete?: boolean\n  autoCorrect?: boolean\n  id?: string\n  editable?: boolean\n  role?: string\n  spellcheck?: boolean\n  tabindex?: number\n  enableGrammarly?: boolean\n}>(), {\n  role: 'textbox',\n  spellcheck: true,\n})\nconst root = ref<HTMLElement | null>(null)\nconst editor = useLexicalComposer()\n\nconst editable = ref(false)\n\nuseMounted(() => {\n  if (root.value) {\n    editor.setRootElement(root.value)\n    editable.value = editor.isEditable()\n  }\n\n  return editor.registerEditableListener((currentIsEditable) => {\n    editable.value = currentIsEditable\n  })\n})\n</script>\n\n<template>\n  <div\n    :id=\"id\"\n    ref=\"root\"\n    :aria-activedescendant=\"!editable ? undefined : ariaActivedescendant\"\n    :aria-autocomplete=\"!editable ? undefined : ariaAutocomplete\"\n    :aria-controls=\"!editable ? undefined : ariaControls\"\n    :aria-describedby=\"ariaDescribedby\"\n    :aria-expanded=\"!editable ? undefined : role === 'combobox' ? !!ariaExpanded ? ariaExpanded : undefined : undefined\"\n    :aria-label=\"ariaLabel\"\n    :aria-labelledby=\"ariaLabelledby\"\n    :aria-multiline=\"ariaMultiline\"\n    :aria-owns=\"!editable ? undefined : ariaOwns\"\n    :aria-required=\"ariaRequired\"\n    :autocapitalize=\"`${autoCapitalize}`\"\n    :autocomplete=\"autoComplete\"\n    :autocorrect=\"`${autoCorrect}`\"\n    :contenteditable=\"editable\"\n    :role=\"!editable ? undefined : role\"\n    :spellcheck=\"spellcheck\"\n    :tabindex=\"tabindex\"\n  />\n</template>\n","<script setup lang=\"ts\">\nimport { useCanShowPlaceholder, useLexicalComposer, usePlainTextSetup } from '../composables'\nimport Decorators from './LexicalDecoratedTeleports'\n\nconst editor = useLexicalComposer()\nconst showPlaceholder = useCanShowPlaceholder(editor)\nusePlainTextSetup(editor)\n</script>\n\n<template>\n  <slot v-if=\"showPlaceholder\" name=\"placeholder\" />\n  <slot name=\"contentEditable\" />\n  <Decorators />\n</template>\n","<script setup lang=\"ts\">\nimport { onMounted, provide } from 'vue'\nimport type { CreateEditorArgs, LexicalEditor } from 'lexical'\nimport { $createParagraphNode, $getRoot, $getSelection, createEditor } from 'lexical'\nimport { LexicalEditorProviderKey } from '../composables/inject'\nimport type { InitialEditorStateType } from '../types'\n\nconst props = defineProps<{\n  initialConfig: CreateEditorArgs\n}>()\n\nconst emit = defineEmits<{\n  (e: 'error', error: Error, editor: LexicalEditor): void\n}>()\n\nconst HISTORY_MERGE_OPTIONS = { tag: 'history-merge' }\n\nconst editor = createEditor({\n  editable: props.initialConfig.editable,\n  html: props.initialConfig.html,\n  namespace: props.initialConfig.namespace,\n  nodes: props.initialConfig.nodes,\n  theme: props.initialConfig.theme,\n  onError(error) {\n    emit('error', error, editor)\n  },\n})\n\ninitializeEditor(editor, props.initialConfig.editorState)\n\nfunction initializeEditor(\n  editor: LexicalEditor,\n  initialEditorState?: InitialEditorStateType,\n): void {\n  if (initialEditorState === null)\n    return\n\n  if (initialEditorState === undefined) {\n    editor.update(() => {\n      const root = $getRoot()\n      if (root.isEmpty()) {\n        const paragraph = $createParagraphNode()\n        root.append(paragraph)\n        const activeElement = document.activeElement\n        if (\n          $getSelection() !== null\n          || (activeElement !== null && activeElement === editor.getRootElement())\n        )\n          paragraph.select()\n      }\n    }, HISTORY_MERGE_OPTIONS)\n  }\n  else if (initialEditorState !== null) {\n    switch (typeof initialEditorState) {\n      case 'string': {\n        const parsedEditorState = editor.parseEditorState(initialEditorState)\n        editor.setEditorState(parsedEditorState, HISTORY_MERGE_OPTIONS)\n        break\n      }\n      case 'object': {\n        editor.setEditorState(initialEditorState, HISTORY_MERGE_OPTIONS)\n        break\n      }\n      case 'function': {\n        editor.update(() => {\n          const root = $getRoot()\n          if (root.isEmpty())\n            initialEditorState(editor)\n        }, HISTORY_MERGE_OPTIONS)\n        break\n      }\n    }\n  }\n}\n\nprovide<LexicalEditor>(LexicalEditorProviderKey, editor)\n\nonMounted(() => {\n  const isEditable = props.initialConfig.editable\n\n  editor.setEditable(isEditable !== undefined ? isEditable : true)\n})\n</script>\n\n<template>\n  <slot />\n</template>\n","<script setup lang=\"ts\">\nimport { onMounted, onUnmounted } from 'vue'\nimport {$getRoot, EditorState, LexicalEditor} from 'lexical'\nimport { useLexicalComposer } from '../composables'\n\nconst props = withDefaults(defineProps<{\n  ignoreInitialChange?: boolean\n  ignoreSelectionChange?: boolean\n  modelValue?: string\n}>(), {\n  ignoreInitialChange: true,\n  ignoreSelectionChange: false,\n})\n\nconst emit = defineEmits<{\n  (e: 'change', editorState: EditorState, editor: LexicalEditor): void\n  (e: 'update:modelValue', payload: string): void\n}>()\n\nconst editor = useLexicalComposer()\n\nlet unregisterListener: () => void\nconst getRoot = $getRoot\n\nonMounted(() => {\n  unregisterListener = editor.registerUpdateListener(({ editorState, dirtyElements, dirtyLeaves, prevEditorState, tags }) => {\n    if (\n      props.ignoreSelectionChange\n      && dirtyElements.size === 0\n      && dirtyLeaves.size === 0\n    )\n      return\n\n    if (props.ignoreInitialChange && prevEditorState.isEmpty())\n      return\n\n    emit('change', editorState, editor)\n\n    editorState.read(() => {\n      emit('update:modelValue', getRoot().getTextContent())\n    })\n  })\n})\n\nonUnmounted(() => {\n  unregisterListener?.()\n})\n</script>\n\n<template />\n","<script setup lang=\"ts\">\nimport type { HistoryState } from '@lexical/history'\nimport { useHistory, useLexicalComposer } from '../composables'\n\nconst props = defineProps<{\n  externalHistoryState?: HistoryState\n}>()\n\nconst editor = useLexicalComposer()\nuseHistory(editor, props.externalHistoryState)\n</script>\n\n<template />\n","<script setup lang=\"ts\">\nimport type {\n  BaseSelection,\n  EditorState,\n  ElementNode,\n  LexicalCommand,\n  LexicalEditor,\n  LexicalNode,\n  RangeSelection,\n  TextNode,\n} from 'lexical'\n\nimport { $generateHtmlFromNodes } from '@lexical/html'\nimport type { LinkNode } from '@lexical/link'\nimport { $isLinkNode } from '@lexical/link'\nimport { $isMarkNode } from '@lexical/mark'\nimport type { TableSelection } from '@lexical/table'\nimport { $isTableSelection } from '@lexical/table'\nimport { mergeRegister } from '@lexical/utils'\nimport {\n  $getRoot,\n  $getSelection,\n  $isElementNode,\n  $isNodeSelection,\n  $isRangeSelection,\n  $isTextNode,\n} from 'lexical'\nimport { computed, ref, watchEffect } from 'vue'\n\nimport { useLexicalCommandsLog, useLexicalComposer } from '../composables'\n\ndefineProps<{\n  treeTypeButtonClassName: string\n  timeTravelButtonClassName: string\n  timeTravelPanelSliderClassName: string\n  timeTravelPanelButtonClassName: string\n  timeTravelPanelClassName: string\n  viewClassName: string\n}>()\n\nconst NON_SINGLE_WIDTH_CHARS_REPLACEMENT: Readonly<Record<string, string>>\n  = Object.freeze({\n    '\\t': '\\\\t',\n    '\\n': '\\\\n',\n  })\nconst NON_SINGLE_WIDTH_CHARS_REGEX = new RegExp(\n  Object.keys(NON_SINGLE_WIDTH_CHARS_REPLACEMENT).join('|'),\n  'g',\n)\nconst SYMBOLS: Record<string, string> = Object.freeze({\n  ancestorHasNextSibling: '|',\n  ancestorIsLastChild: ' ',\n  hasNextSibling: '├',\n  isLastChild: '└',\n  selectedChar: '^',\n  selectedLine: '>',\n})\n\nfunction printRangeSelection(selection: RangeSelection): string {\n  let res = ''\n\n  const formatText = printFormatProperties(selection)\n\n  res += `: range ${formatText !== '' ? `{ ${formatText} }` : ''}`\n\n  const anchor = selection.anchor\n  const focus = selection.focus\n  const anchorOffset = anchor.offset\n  const focusOffset = focus.offset\n\n  res += `\\n  ├ anchor { key: ${anchor.key}, offset: ${\n    anchorOffset === null ? 'null' : anchorOffset\n  }, type: ${anchor.type} }`\n  res += `\\n  └ focus { key: ${focus.key}, offset: ${\n    focusOffset === null ? 'null' : focusOffset\n  }, type: ${focus.type} }`\n\n  return res\n}\n\nfunction generateContent(\n  editor: LexicalEditor,\n  commandsLog: ReadonlyArray<LexicalCommand<unknown> & { payload: unknown }>,\n  exportDOM: boolean,\n): string {\n  const editorState = editor.getEditorState()\n  const editorConfig = editor._config\n  const compositionKey = editor._compositionKey\n  const editable = editor._editable\n\n  if (exportDOM) {\n    let htmlString = ''\n    editorState.read(() => {\n      htmlString = printPrettyHTML($generateHtmlFromNodes(editor))\n    })\n    return htmlString\n  }\n\n  let res = ' root\\n'\n\n  const selectionString = editorState.read(() => {\n    const selection = $getSelection()\n\n    visitTree($getRoot(), (node: LexicalNode, indent: Array<string>) => {\n      const nodeKey = node.getKey()\n      const nodeKeyDisplay = `(${nodeKey})`\n      const typeDisplay = node.getType() || ''\n      const isSelected = node.isSelected()\n      const idsDisplay = $isMarkNode(node)\n        ? ` id: [ ${node.getIDs().join(', ')} ] `\n        : ''\n\n      res += `${isSelected ? SYMBOLS.selectedLine : ' '} ${indent.join(\n        ' ',\n      )} ${nodeKeyDisplay} ${typeDisplay} ${idsDisplay} ${printNode(node)}\\n`\n\n      res += printSelectedCharsLine({\n        indent,\n        isSelected,\n        node,\n        nodeKeyDisplay,\n        selection,\n        typeDisplay,\n      })\n    })\n\n    return selection === null\n      ? ': null'\n      : $isRangeSelection(selection)\n        ? printRangeSelection(selection)\n        : $isTableSelection(selection)\n          ? printTableSelection(selection)\n          : printNodeSelection(selection)\n  })\n\n  res += `\\n selection${selectionString}`\n\n  res += '\\n\\n commands:'\n\n  if (commandsLog.length) {\n    for (const { type, payload } of commandsLog) {\n      res += `\\n  └ { type: ${type}, payload: ${\n        payload instanceof Event ? payload.constructor.name : payload\n      } }`\n    }\n  }\n  else {\n    res += '\\n  └ None dispatched.'\n  }\n\n  res += '\\n\\n editor:'\n  res += `\\n  └ namespace ${editorConfig.namespace}`\n  if (compositionKey !== null)\n    res += `\\n  └ compositionKey ${compositionKey}`\n\n  res += `\\n  └ editable ${String(editable)}`\n\n  return res\n}\n\nfunction printNodeSelection(selection: BaseSelection): string {\n  if (!$isNodeSelection(selection))\n    return ''\n  return `: node\\n  └ [${Array.from(selection._nodes).join(', ')}]`\n}\n\nfunction printTableSelection(selection: TableSelection): string {\n  return `: table\\n  └ { table: ${selection.tableKey}, anchorCell: ${selection.anchor.key}, focusCell: ${selection.focus.key} }`\n}\n\nfunction visitTree(\n  currentNode: ElementNode,\n  visitor: (node: LexicalNode, indentArr: Array<string>) => void,\n  indent: Array<string> = [],\n) {\n  const childNodes = currentNode.getChildren()\n  const childNodesLength = childNodes.length\n\n  childNodes.forEach((childNode, i) => {\n    visitor(\n      childNode,\n      indent.concat(\n        i === childNodesLength - 1\n          ? SYMBOLS.isLastChild\n          : SYMBOLS.hasNextSibling,\n      ),\n    )\n\n    if ($isElementNode(childNode)) {\n      visitTree(\n        childNode,\n        visitor,\n        indent.concat(\n          i === childNodesLength - 1\n            ? SYMBOLS.ancestorIsLastChild\n            : SYMBOLS.ancestorHasNextSibling,\n        ),\n      )\n    }\n  })\n}\n\nfunction normalize(text: string) {\n  return Object.entries(NON_SINGLE_WIDTH_CHARS_REPLACEMENT).reduce(\n    (acc, [key, value]) => acc.replace(new RegExp(key, 'g'), String(value)),\n    text,\n  )\n}\n\n// TODO Pass via props to allow customizability\nfunction printNode(node: LexicalNode) {\n  if ($isTextNode(node)) {\n    const text = node.getTextContent()\n    const title = text.length === 0 ? '(empty)' : `\"${normalize(text)}\"`\n    const properties = printAllTextNodeProperties(node)\n    return [title, properties.length !== 0 ? `{ ${properties} }` : null]\n      .filter(Boolean)\n      .join(' ')\n      .trim()\n  }\n  else if ($isLinkNode(node)) {\n    const link = node.getURL()\n    const title = link.length === 0 ? '(empty)' : `\"${normalize(link)}\"`\n    const properties = printAllLinkNodeProperties(node)\n    return [title, properties.length !== 0 ? `{ ${properties} }` : null]\n      .filter(Boolean)\n      .join(' ')\n      .trim()\n  }\n  else {\n    return ''\n  }\n}\n\nconst FORMAT_PREDICATES = [\n  (node: TextNode | RangeSelection) => node.hasFormat('bold') && 'Bold',\n  (node: TextNode | RangeSelection) => node.hasFormat('code') && 'Code',\n  (node: TextNode | RangeSelection) => node.hasFormat('italic') && 'Italic',\n  (node: TextNode | RangeSelection) =>\n    node.hasFormat('strikethrough') && 'Strikethrough',\n  (node: TextNode | RangeSelection) =>\n    node.hasFormat('subscript') && 'Subscript',\n  (node: TextNode | RangeSelection) =>\n    node.hasFormat('superscript') && 'Superscript',\n  (node: TextNode | RangeSelection) =>\n    node.hasFormat('underline') && 'Underline',\n]\n\nconst DETAIL_PREDICATES = [\n  (node: TextNode) => node.isDirectionless() && 'Directionless',\n  (node: TextNode) => node.isUnmergeable() && 'Unmergeable',\n]\n\nconst MODE_PREDICATES = [\n  (node: TextNode) => node.isToken() && 'Token',\n  (node: TextNode) => node.isSegmented() && 'Segmented',\n]\n\nfunction printAllTextNodeProperties(node: TextNode) {\n  return [\n    printFormatProperties(node),\n    printDetailProperties(node),\n    printModeProperties(node),\n  ]\n    .filter(Boolean)\n    .join(', ')\n}\n\nfunction printAllLinkNodeProperties(node: LinkNode) {\n  return [\n    printTargetProperties(node),\n    printRelProperties(node),\n    printTitleProperties(node),\n  ]\n    .filter(Boolean)\n    .join(', ')\n}\n\nfunction printDetailProperties(nodeOrSelection: TextNode) {\n  let str = DETAIL_PREDICATES.map(predicate => predicate(nodeOrSelection))\n    .filter(Boolean)\n    .join(', ')\n    .toLocaleLowerCase()\n\n  if (str !== '')\n    str = `detail: ${str}`\n\n  return str\n}\n\nfunction printModeProperties(nodeOrSelection: TextNode) {\n  let str = MODE_PREDICATES.map(predicate => predicate(nodeOrSelection))\n    .filter(Boolean)\n    .join(', ')\n    .toLocaleLowerCase()\n\n  if (str !== '')\n    str = `mode: ${str}`\n\n  return str\n}\n\nfunction printFormatProperties(nodeOrSelection: TextNode | RangeSelection) {\n  let str = FORMAT_PREDICATES.map(predicate => predicate(nodeOrSelection))\n    .filter(Boolean)\n    .join(', ')\n    .toLocaleLowerCase()\n\n  if (str !== '')\n    str = `format: ${str}`\n\n  return str\n}\n\nfunction printTargetProperties(node: LinkNode) {\n  let str = node.getTarget()\n  // TODO Fix nullish on LinkNode\n  if (str != null)\n    str = `target: ${str}`\n\n  return str\n}\n\nfunction printRelProperties(node: LinkNode) {\n  let str = node.getRel()\n  // TODO Fix nullish on LinkNode\n  if (str != null)\n    str = `rel: ${str}`\n\n  return str\n}\n\nfunction printTitleProperties(node: LinkNode) {\n  let str = node.getTitle()\n  // TODO Fix nullish on LinkNode\n  if (str != null)\n    str = `title: ${str}`\n\n  return str\n}\n\nfunction printSelectedCharsLine({\n  indent,\n  isSelected,\n  node,\n  nodeKeyDisplay,\n  selection,\n  typeDisplay,\n}: {\n  indent: Array<string>\n  isSelected: boolean\n  node: LexicalNode\n  nodeKeyDisplay: string\n  selection: BaseSelection | null\n  typeDisplay: string\n}) {\n  // No selection or node is not selected.\n  if (\n    !$isTextNode(node)\n    || !$isRangeSelection(selection)\n    || !isSelected\n    || $isElementNode(node)\n  )\n    return ''\n\n  // No selected characters.\n  const anchor = selection.anchor\n  const focus = selection.focus\n\n  if (\n    node.getTextContent() === ''\n    || (anchor.getNode() === selection.focus.getNode()\n    && anchor.offset === focus.offset)\n  )\n    return ''\n\n  const [start, end] = $getSelectionStartEnd(node, selection)\n\n  if (start === end)\n    return ''\n\n  const selectionLastIndent\n    = indent[indent.length - 1] === SYMBOLS.hasNextSibling\n      ? SYMBOLS.ancestorHasNextSibling\n      : SYMBOLS.ancestorIsLastChild\n\n  const indentionChars = [\n    ...indent.slice(0, indent.length - 1),\n    selectionLastIndent,\n  ]\n  const unselectedChars = Array(start + 1).fill(' ')\n  const selectedChars = Array(end - start).fill(SYMBOLS.selectedChar)\n  const paddingLength = typeDisplay.length + 3 // 2 for the spaces around + 1 for the double quote.\n\n  const nodePrintSpaces = Array(nodeKeyDisplay.length + paddingLength).fill(\n    ' ',\n  )\n\n  return (\n    `${[\n      SYMBOLS.selectedLine,\n      indentionChars.join(' '),\n      [...nodePrintSpaces, ...unselectedChars, ...selectedChars].join(''),\n    ].join(' ')}\\n`\n  )\n}\n\nfunction printPrettyHTML(str: string) {\n  const div = document.createElement('div')\n  div.innerHTML = str.trim()\n  return prettifyHTML(div, 0).innerHTML\n}\n\nfunction prettifyHTML(node: Element, level: number) {\n  const indentBefore = Array.from({ length: level++ + 1 }).join('  ')\n  const indentAfter = Array.from({ length: level - 1 }).join('  ')\n  let textNode\n\n  for (let i = 0; i < node.children.length; i++) {\n    textNode = document.createTextNode(`\\n${indentBefore}`)\n    node.insertBefore(textNode, node.children[i])\n    prettifyHTML(node.children[i], level)\n    if (node.lastElementChild === node.children[i]) {\n      textNode = document.createTextNode(`\\n${indentAfter}`)\n      node.appendChild(textNode)\n    }\n  }\n\n  return node\n}\n\nfunction $getSelectionStartEnd(\n  node: LexicalNode,\n  selection: BaseSelection,\n): [number, number] {\n  const anchorAndFocus = selection.getStartEndPoints()\n  if ($isNodeSelection(selection) || anchorAndFocus === null)\n    return [-1, -1]\n\n  const [anchor, focus] = anchorAndFocus\n  const textContent = node.getTextContent()\n  const textLength = textContent.length\n\n  let start = -1\n  let end = -1\n\n  // Only one node is being selected.\n  if (anchor.type === 'text' && focus.type === 'text') {\n    const anchorNode = anchor.getNode()\n    const focusNode = focus.getNode()\n\n    if (\n      anchorNode === focusNode\n      && node === anchorNode\n      && anchor.offset !== focus.offset\n    ) {\n      [start, end]\n        = anchor.offset < focus.offset\n          ? [anchor.offset, focus.offset]\n          : [focus.offset, anchor.offset]\n    }\n    else if (node === anchorNode) {\n      [start, end] = anchorNode.isBefore(focusNode)\n        ? [anchor.offset, textLength]\n        : [0, anchor.offset]\n    }\n    else if (node === focusNode) {\n      [start, end] = focusNode.isBefore(anchorNode)\n        ? [focus.offset, textLength]\n        : [0, focus.offset]\n    }\n    else {\n      // Node is within selection but not the anchor nor focus.\n      [start, end] = [0, textLength]\n    }\n  }\n\n  // Account for non-single width characters.\n  const numNonSingleWidthCharBeforeSelection = (\n    textContent.slice(0, start).match(NON_SINGLE_WIDTH_CHARS_REGEX) || []\n  ).length\n  const numNonSingleWidthCharInSelection = (\n    textContent.slice(start, end).match(NON_SINGLE_WIDTH_CHARS_REGEX) || []\n  ).length\n\n  return [\n    start + numNonSingleWidthCharBeforeSelection,\n    end\n    + numNonSingleWidthCharBeforeSelection\n    + numNonSingleWidthCharInSelection,\n  ]\n}\n\nconst editor = useLexicalComposer()\n\nconst timeStampedEditorStates = ref<[number, EditorState][]>([])\nconst content = ref('')\nconst timeTravelEnabled = ref(false)\nconst showExportDOM = ref(false)\nconst playingIndexRef = ref(0)\nconst treeElementRef = ref<HTMLPreElement | null>(null)\nconst inputRef = ref<HTMLInputElement | null>(null)\nconst isPlaying = ref(false)\nconst isLimited = ref(false)\nconst showLimited = ref(false)\nconst lastEditorStateRef = ref<EditorState | null>(null)\n\nconst commandsLog = useLexicalCommandsLog(editor)\n\nfunction generateTree(editorState: EditorState) {\n  const treeText = generateContent(editor, commandsLog.value, showExportDOM.value)\n\n  content.value = treeText\n\n  if (!timeTravelEnabled.value) {\n    timeStampedEditorStates.value = [\n      ...timeStampedEditorStates.value,\n      [Date.now(), editorState],\n    ]\n  }\n}\n\nwatchEffect(() => {\n  const editorState = editor.getEditorState()\n\n  if (!showLimited.value && editorState._nodeMap.size < 1000)\n    content.value = generateContent(editor, commandsLog.value, showExportDOM.value)\n})\n\nwatchEffect((onInvalidate) => {\n  const unregisterListener = mergeRegister(\n    editor.registerUpdateListener(({ editorState }) => {\n      if (!showLimited.value && editorState._nodeMap.size > 1000) {\n        lastEditorStateRef.value = editorState\n        isLimited.value = true\n        if (!showLimited.value)\n          return\n      }\n      generateTree(editorState)\n    }),\n    editor.registerEditableListener(() => {\n      const treeText = generateContent(editor, commandsLog.value, showExportDOM.value)\n      content.value = treeText\n    }),\n  )\n\n  onInvalidate(() => {\n    unregisterListener()\n  })\n})\n\nconst totalEditorStates = computed(() => timeStampedEditorStates.value.length)\n\nlet timeoutId: ReturnType<typeof setTimeout>\n\nwatchEffect((onInvalidate) => {\n  if (isPlaying.value) {\n    const play = () => {\n      const currentIndex = playingIndexRef.value\n\n      if (currentIndex === totalEditorStates.value - 1) {\n        isPlaying.value = false\n        return\n      }\n\n      const currentTime = timeStampedEditorStates.value[currentIndex][0]\n      const nextTime = timeStampedEditorStates.value[currentIndex + 1][0]\n      const timeDiff = nextTime - currentTime\n      timeoutId = setTimeout(() => {\n        playingIndexRef.value++\n        const index = playingIndexRef.value\n        const input = inputRef.value\n\n        if (input !== null)\n          input.value = String(index)\n\n        editor.setEditorState(timeStampedEditorStates.value[index][1])\n        play()\n      }, timeDiff)\n    }\n\n    play()\n  }\n\n  onInvalidate(() => {\n    clearTimeout(timeoutId)\n  })\n})\n\nlet element: HTMLPreElement | null = null\n\nwatchEffect((onInvalidate) => {\n  element = treeElementRef.value\n\n  if (element !== null) {\n    // @ts-expect-error: Internal field\n    element.__lexicalEditor = editor\n\n    onInvalidate(() => {\n    // @ts-expect-error Internal field\n      element.__lexicalEditor = null\n    })\n  }\n})\n\nfunction enableTimeTravel() {\n  const rootElement = editor.getRootElement()\n  if (rootElement !== null) {\n    rootElement.contentEditable = 'false'\n    playingIndexRef.value = totalEditorStates.value - 1\n    timeTravelEnabled.value = true\n  }\n}\n\nfunction updateEditorState(e: Event) {\n  const editorStateIndex = Number((e.target as HTMLInputElement).value)\n  const timeStampedEditorState\n                = timeStampedEditorStates.value[editorStateIndex]\n  if (timeStampedEditorState) {\n    playingIndexRef.value = editorStateIndex\n    editor.setEditorState(timeStampedEditorState[1])\n  }\n}\n\nfunction exit() {\n  const rootElement = editor.getRootElement()\n  if (rootElement) {\n    rootElement.contentEditable = 'true'\n    const index = timeStampedEditorStates.value.length - 1\n    const timeStampedEditorState = timeStampedEditorStates.value[index]\n    editor.setEditorState(timeStampedEditorState[1])\n    const input = inputRef.value\n    if (input)\n      input.value = String(index)\n\n    timeTravelEnabled.value = false\n    isPlaying.value = false\n  }\n}\n</script>\n\n<template>\n  <div :class=\"viewClassName\">\n    <div v-if=\"showLimited && isLimited\" style=\"padding: 20px\">\n      <span style=\"margin-right: 20px;\">\n        Detected large EditorState, this can impact debugging performance.\n      </span>\n\n      <button\n        style=\"background: transparent; border: 1px solid white; color: white; cursor: pointer; padding: 5px\"\n        @click=\"{\n          showLimited = false;\n          const editorState = lastEditorStateRef;\n          if (editorState !== null) {\n            lastEditorStateRef = null;\n            generateTree(editorState);\n          }\n        }\"\n      >\n        Show full tree\n      </button>\n    </div>\n\n    <div v-if=\"!showLimited\">\n      <button\n        :class=\"treeTypeButtonClassName\"\n        type=\"button\"\n        @click=\"showExportDOM = !showExportDOM\"\n      >\n        {{ showExportDOM ? 'Tree' : 'Export DOM' }}\n      </button>\n    </div>\n\n    <button\n      v-if=\"!timeTravelEnabled && (showLimited || !isLimited) && totalEditorStates > 2\"\n      :class=\"timeTravelButtonClassName\"\n      @click=\"enableTimeTravel\"\n    >\n      Time Travel\n    </button>\n    <pre v-if=\"showLimited || !isLimited\" ref=\"treeElementRef\">{{ content }}</pre>\n    <div v-if=\"timeTravelEnabled && (showLimited || !isLimited)\" :class=\"timeTravelPanelClassName\">\n      <button\n        :class=\"timeTravelPanelButtonClassName\"\n        @click=\"{\n          if (playingIndexRef === totalEditorStates - 1) {\n            playingIndexRef = 1;\n          }\n          isPlaying = !isPlaying;\n        }\"\n      >\n        {{ isPlaying ? 'Pause' : 'Play' }}\n      </button>\n      <input\n        ref=\"inputRef\"\n        :class=\"timeTravelPanelSliderClassName\"\n        type=\"range\"\n        min=\"1\"\n        :max=\"totalEditorStates - 1\"\n        @input=\"updateEditorState\"\n      >\n      <button :class=\"timeTravelPanelButtonClassName\" @click=\"exit\">\n        Exit\n      </button>\n    </div>\n  </div>\n</template>\n","<script setup lang=\"ts\">\nimport { nextTick, onMounted } from 'vue'\nimport { useLexicalComposer } from '../composables'\n\nconst props = defineProps<{\n  defaultSelection?: 'rootStart' | 'rootEnd'\n}>()\n\nconst editor = useLexicalComposer()\n\nonMounted(() => {\n  nextTick(() => {\n    editor.focus(\n      () => {\n      // If we try and move selection to the same point with setBaseAndExtent, it won't\n      // trigger a re-focus on the element. So in the case this occurs, we'll need to correct it.\n      // Normally this is fine, Selection API !== Focus API, but fore the intents of the naming\n      // of this plugin, which should preserve focus too.\n        const activeElement = document.activeElement\n        const rootElement = editor.getRootElement() as HTMLDivElement\n        if (\n          rootElement !== null\n          && (activeElement === null || !rootElement.contains(activeElement))\n        ) {\n        // Note: preventScroll won't work in Webkit.\n          rootElement.focus({ preventScroll: true })\n        }\n      },\n      { defaultSelection: props.defaultSelection },\n    )\n  })\n})\n</script>\n\n<template />\n","<script setup lang=\"ts\">\nimport { useCanShowPlaceholder, useLexicalComposer, useRichTextSetup } from '../composables'\nimport Decorators from './LexicalDecoratedTeleports'\n\nconst editor = useLexicalComposer()\nconst showPlaceholder = useCanShowPlaceholder(editor)\nuseRichTextSetup(editor)\n</script>\n\n<template>\n  <slot name=\"contentEditable\" />\n  <slot v-if=\"showPlaceholder\" name=\"placeholder\" />\n  <Decorators />\n</template>\n","<script setup lang=\"ts\">\nimport { useLexicalComposer, useList } from '../composables'\n\nconst editor = useLexicalComposer()\nuseList(editor)\n</script>\n\n<template />\n","<script setup lang=\"ts\">\nimport {\n  LinkNode,\n  TOGGLE_LINK_COMMAND,\n  toggleLink,\n} from '@lexical/link'\nimport {\n  $getSelection,\n  $isElementNode,\n  $isRangeSelection,\n  COMMAND_PRIORITY_LOW,\n  PASTE_COMMAND,\n} from 'lexical'\nimport invariant from 'tiny-invariant'\nimport { mergeRegister } from '@lexical/utils'\nimport { useLexicalComposer } from '../composables'\nimport { useMounted } from '../composables/useMounted'\n\nconst props = defineProps<{\n  validateUrl?: (url: string) => boolean\n}>()\nconst editor = useLexicalComposer()\nuseMounted(() => {\n  if (!editor.hasNodes([LinkNode]))\n    invariant(false, 'LinkPlugin: LinkNode not registered on editor')\n\n  return mergeRegister(\n    editor.registerCommand(\n      TOGGLE_LINK_COMMAND,\n      (payload) => {\n        if (payload === null) {\n          toggleLink(payload)\n          return true\n        }\n        else if (typeof payload === 'string') {\n          if (props.validateUrl === undefined || props.validateUrl(payload)) {\n            toggleLink(payload)\n            return true\n          }\n          return false\n        }\n        else {\n          const { url, target, rel, title } = payload\n          toggleLink(url, { rel, target, title })\n          return true\n        }\n      },\n      COMMAND_PRIORITY_LOW,\n    ),\n    props.validateUrl !== undefined\n      ? editor.registerCommand(\n        PASTE_COMMAND,\n        (event) => {\n          const selection = $getSelection()\n          if (\n            !$isRangeSelection(selection)\n            || selection.isCollapsed()\n            || !(event instanceof ClipboardEvent)\n            || event.clipboardData == null\n          )\n            return false\n\n          const clipboardText = event.clipboardData.getData('text')\n          if (!props.validateUrl?.(clipboardText))\n            return false\n\n          // If we select nodes that are elements then avoid applying the link.\n          if (!selection.getNodes().some(node => $isElementNode(node))) {\n            editor.dispatchCommand(TOGGLE_LINK_COMMAND, clipboardText)\n            event.preventDefault()\n            return true\n          }\n          return false\n        },\n        COMMAND_PRIORITY_LOW,\n      )\n      : () => {\n          // Don't paste arbritrary text as a link when there's no validate function\n        },\n  )\n})\n</script>\n\n<template />\n","<script setup lang=\"ts\">\nimport type {\n  HTMLTableElementWithWithTableSelectionState,\n  InsertTableCommandPayload,\n  TableObserver,\n} from '@lexical/table'\nimport {\n  $computeTableMap,\n  $createTableCellNode,\n  $createTableNodeWithDimensions,\n  $getNodeTriplet,\n  $isTableCellNode,\n  $isTableNode,\n  $isTableRowNode,\n  INSERT_TABLE_COMMAND,\n  TableCellNode,\n  TableNode,\n  TableRowNode,\n  applyTableHandlers,\n} from '@lexical/table'\nimport { $insertFirst, $insertNodeToNearestRoot } from '@lexical/utils'\nimport type {\n  NodeKey,\n} from 'lexical'\nimport {\n  $getNodeByKey,\n  $isTextNode,\n  $nodesOfType,\n  COMMAND_PRIORITY_EDITOR,\n} from 'lexical'\nimport invariant from 'tiny-invariant'\nimport { useEffect, useLexicalComposer, useMounted } from '../composables'\n\nconst props = withDefaults(defineProps<{\n  hasCellMerge?: boolean\n  hasCellBackgroundColor?: boolean\n  hasTabHandler?: boolean\n}>(), {\n  hasCellMerge: true,\n  hasCellBackgroundColor: true,\n  hasTabHandler: true,\n})\n\nconst editor = useLexicalComposer()\n\nuseMounted(() => {\n  if (!editor.hasNodes([TableNode, TableCellNode, TableRowNode])) {\n    invariant(\n        false,\n        'TablePlugin: TableNode, TableCellNode or TableRowNode not registered on editor',\n    )\n  }\n\n  return editor.registerCommand<InsertTableCommandPayload>(\n      INSERT_TABLE_COMMAND,\n      ({ columns, rows, includeHeaders }) => {\n        const tableNode = $createTableNodeWithDimensions(\n            Number(rows),\n            Number(columns),\n            includeHeaders,\n        )\n        $insertNodeToNearestRoot(tableNode)\n\n        const firstDescendant = tableNode.getFirstDescendant()\n        if ($isTextNode(firstDescendant))\n          firstDescendant.select()\n\n        return true\n      },\n      COMMAND_PRIORITY_EDITOR,\n  )\n})\n\nuseMounted(() => {\n  const tableSelections = new Map<NodeKey, TableObserver>()\n\n  const initializeTableNode = (tableNode: TableNode) => {\n    const nodeKey = tableNode.getKey()\n    const tableElement = editor.getElementByKey(\n        nodeKey,\n    ) as HTMLTableElementWithWithTableSelectionState\n    if (tableElement && !tableSelections.has(nodeKey)) {\n      const tableSelection = applyTableHandlers(\n          tableNode,\n          tableElement,\n          editor,\n          props.hasTabHandler,\n      )\n      tableSelections.set(nodeKey, tableSelection)\n    }\n  }\n\n  // Plugins might be loaded _after_ initial content is set, hence existing table nodes\n  // won't be initialized from mutation[create] listener. Instead doing it here,\n  editor.getEditorState().read(() => {\n    const tableNodes = $nodesOfType(TableNode)\n    for (const tableNode of tableNodes) {\n      if ($isTableNode(tableNode))\n        initializeTableNode(tableNode)\n    }\n  })\n\n  const unregisterMutationListener = editor.registerMutationListener(\n      TableNode,\n      (nodeMutations) => {\n        for (const [nodeKey, mutation] of nodeMutations) {\n          if (mutation === 'created') {\n            editor.getEditorState().read(() => {\n              const tableNode = $getNodeByKey<TableNode>(nodeKey)\n              if ($isTableNode(tableNode))\n                initializeTableNode(tableNode)\n            })\n          }\n          else if (mutation === 'destroyed') {\n            const tableSelection = tableSelections.get(nodeKey)\n\n            if (tableSelection !== undefined) {\n              tableSelection.removeListeners()\n              tableSelections.delete(nodeKey)\n            }\n          }\n        }\n      },\n  )\n\n  return () => {\n    unregisterMutationListener()\n    // Hook might be called multiple times so cleaning up tables listeners as well,\n    // as it'll be reinitialized during recurring call\n    for (const [, tableSelection] of tableSelections)\n      tableSelection.removeListeners()\n  }\n})\n\n// Unmerge cells when the feature isn't enabled\nuseEffect(() => {\n  if (props.hasCellMerge)\n    return\n\n  return editor.registerNodeTransform(TableCellNode, (node) => {\n    if (node.getColSpan() > 1 || node.getRowSpan() > 1) {\n      // When we have rowSpan we have to map the entire Table to understand where the new Cells\n      // fit best; let's analyze all Cells at once to save us from further transform iterations\n      const [, , gridNode] = $getNodeTriplet(node)\n      const [gridMap] = $computeTableMap(gridNode, node, node)\n      // TODO this function expects Tables to be normalized. Look into this once it exists\n      const rowsCount = gridMap.length\n      const columnsCount = gridMap[0].length\n      let row = gridNode.getFirstChild()\n      invariant(\n          $isTableRowNode(row),\n          'Expected TableNode first child to be a RowNode',\n      )\n\n      const unmerged = []\n      for (let i = 0; i < rowsCount; i++) {\n        if (i !== 0) {\n          row = row.getNextSibling()\n          invariant(\n              $isTableRowNode(row),\n              'Expected TableNode first child to be a RowNode',\n          )\n        }\n        let lastRowCell: null | TableCellNode = null\n        for (let j = 0; j < columnsCount; j++) {\n          const cellMap = gridMap[i][j]\n          const cell = cellMap.cell\n          if (cellMap.startRow === i && cellMap.startColumn === j) {\n            lastRowCell = cell\n            unmerged.push(cell)\n          }\n          else if (cell.getColSpan() > 1 || cell.getRowSpan() > 1) {\n            invariant(\n                $isTableCellNode(cell),\n                'Expected TableNode cell to be a TableCellNode',\n            )\n            const newCell = $createTableCellNode(cell.__headerState)\n            if (lastRowCell !== null)\n              lastRowCell.insertAfter(newCell)\n            else\n              $insertFirst(row, newCell)\n          }\n        }\n      }\n      for (const cell of unmerged) {\n        cell.setColSpan(1)\n        cell.setRowSpan(1)\n      }\n    }\n  })\n})\n\nuseEffect(() => {\n  if (props.hasCellBackgroundColor)\n    return\n\n  return editor.registerNodeTransform(TableCellNode, (node) => {\n    if (node.getBackgroundColor() !== null)\n      node.setBackgroundColor(null)\n  })\n})\n</script>\n\n<template />","<script setup lang=\"ts\">\nimport {\n  $createParagraphNode,\n  $getRoot,\n  $getSelection,\n  CLEAR_EDITOR_COMMAND,\n  COMMAND_PRIORITY_EDITOR,\n} from 'lexical'\nimport { useAttrs } from 'vue'\nimport { useLexicalComposer } from '../composables'\nimport { useMounted } from '../composables/useMounted'\n\nconst emit = defineEmits<{\n  (e: 'clear'): void\n}>()\nconst editor = useLexicalComposer()\nconst attrs = useAttrs()\n\nuseMounted(() => {\n  const emitExists = Boolean(attrs.onClear)\n\n  return editor.registerCommand(\n    CLEAR_EDITOR_COMMAND,\n    (_payload) => {\n      editor.update(() => {\n        if (emitExists) {\n          const root = $getRoot()\n          const selection = $getSelection()\n          const paragraph = $createParagraphNode()\n          root.clear()\n          root.append(paragraph)\n          if (selection !== null)\n            paragraph.select()\n        }\n        else {\n          emit('clear')\n        }\n      })\n      return true\n    },\n    COMMAND_PRIORITY_EDITOR,\n  )\n})\n</script>\n\n<template />\n","<script setup lang=\"ts\">\nimport { computed, ref } from 'vue'\nimport { useCharacterLimit, useLexicalComposer } from '../composables'\n\nconst props = withDefaults(defineProps<{\n  charset?: 'UTF-8' | 'UTF-16'\n}>(), {\n  charset: 'UTF-16',\n})\n\nconst editor = useLexicalComposer()\n\nconst CHARACTER_LIMIT = 5\n\nlet textEncoderInstance: TextEncoder | null = null\n\nfunction textEncoder(): null | TextEncoder {\n  if (window.TextEncoder === undefined)\n    return null\n\n  if (textEncoderInstance === null)\n    textEncoderInstance = new window.TextEncoder()\n\n  return textEncoderInstance\n}\n\nfunction utf8Length(text: string) {\n  const currentTextEncoder = textEncoder()\n\n  if (currentTextEncoder === null) {\n    // http://stackoverflow.com/a/5515960/210370\n    const m = encodeURIComponent(text).match(/%[89ABab]/g)\n    return text.length + (m ? m.length : 0)\n  }\n\n  return currentTextEncoder.encode(text).length\n}\n\nconst remainingCharacters = ref(0)\nfunction setRemainingCharacters(payload: number) {\n  remainingCharacters.value = payload\n}\n\nconst characterLimitProps = computed(\n  () => ({\n    remainingCharacters: setRemainingCharacters,\n    strlen: (text: string) => {\n      if (props.charset === 'UTF-8')\n        return utf8Length(text)\n\n      else if (props.charset === 'UTF-16')\n        return text.length\n\n      else\n        throw new Error('Unrecognized charset')\n    },\n  }),\n)\n\nuseCharacterLimit(editor, CHARACTER_LIMIT, characterLimitProps.value)\n</script>\n\n<template>\n  <span\n    :class=\"`characters-limit ${\n      remainingCharacters < 0 ? 'characters-limit-exceeded' : ''\n    }`\"\n  >\n    {{ remainingCharacters }}\n  </span>\n</template>\n","<script setup lang=\"ts\">\nimport { $getSelection, $isRangeSelection } from 'lexical'\nimport { useLexicalComposer } from '../composables'\nimport { useMounted } from '../composables/useMounted'\n\nconst props = defineProps<{\n  scrollRef: HTMLElement | null\n}>()\n\nconst editor = useLexicalComposer()\n\nuseMounted(() => {\n  return editor.registerUpdateListener(({ tags, editorState }) => {\n    const scrollElement = props.scrollRef\n    if (!scrollElement || !tags.has('scroll-into-view'))\n      return\n\n    const selection = editorState.read(() => $getSelection())\n    if (!$isRangeSelection(selection) || !selection.isCollapsed())\n      return\n\n    const anchorElement = editor.getElementByKey(selection.anchor.key)\n    if (anchorElement === null)\n      return\n\n    const scrollRect = scrollElement.getBoundingClientRect()\n    const rect = anchorElement.getBoundingClientRect()\n    if (rect.bottom > scrollRect.bottom)\n      anchorElement.scrollIntoView(false)\n\n    else if (rect.top < scrollRect.top)\n      anchorElement.scrollIntoView()\n  })\n})\n</script>\n","<script setup lang=\"ts\">\nimport type { TextNode } from 'lexical'\n\nimport { $createHashtagNode, HashtagNode } from '@lexical/hashtag'\nimport { onMounted } from 'vue'\nimport invariant from 'tiny-invariant'\nimport { useLexicalComposer, useLexicalTextEntity } from '../composables'\n\nfunction getHashtagRegexStringChars(): {\n  alpha: string\n  alphanumeric: string\n  hashChars: string\n} {\n  // Latin accented characters\n  // Excludes 0xd7 from the range\n  // (the multiplication sign, confusable with \"x\").\n  // Also excludes 0xf7, the division sign\n  const latinAccents\n    = '\\xC0-\\xD6'\n    + '\\xD8-\\xF6'\n    + '\\xF8-\\xFF'\n    + '\\u0100-\\u024F'\n    + '\\u0253-\\u0254'\n    + '\\u0256-\\u0257'\n    + '\\u0259'\n    + '\\u025B'\n    + '\\u0263'\n    + '\\u0268'\n    + '\\u026F'\n    + '\\u0272'\n    + '\\u0289'\n    + '\\u028B'\n    + '\\u02BB'\n    + '\\u0300-\\u036F'\n    + '\\u1E00-\\u1EFF'\n\n  // Cyrillic (Russian, Ukrainian, etc.)\n  const nonLatinChars\n    = '\\u0400-\\u04FF' // Cyrillic\n    + '\\u0500-\\u0527' // Cyrillic Supplement\n    + '\\u2DE0-\\u2DFF' // Cyrillic Extended A\n    + '\\uA640-\\uA69F' // Cyrillic Extended B\n    + '\\u0591-\\u05BF' // Hebrew\n    + '\\u05C1-\\u05C2'\n    + '\\u05C4-\\u05C5'\n    + '\\u05C7'\n    + '\\u05D0-\\u05EA'\n    + '\\u05F0-\\u05F4'\n    + '\\uFB12-\\uFB28' // Hebrew Presentation Forms\n    + '\\uFB2A-\\uFB36'\n    + '\\uFB38-\\uFB3C'\n    + '\\uFB3E'\n    + '\\uFB40-\\uFB41'\n    + '\\uFB43-\\uFB44'\n    + '\\uFB46-\\uFB4F'\n    + '\\u0610-\\u061A' // Arabic\n    + '\\u0620-\\u065F'\n    + '\\u066E-\\u06D3'\n    + '\\u06D5-\\u06DC'\n    + '\\u06DE-\\u06E8'\n    + '\\u06EA-\\u06EF'\n    + '\\u06FA-\\u06FC'\n    + '\\u06FF'\n    + '\\u0750-\\u077F' // Arabic Supplement\n    + '\\u08A0' // Arabic Extended A\n    + '\\u08A2-\\u08AC'\n    + '\\u08E4-\\u08FE'\n    + '\\uFB50-\\uFBB1' // Arabic Pres. Forms A\n    + '\\uFBD3-\\uFD3D'\n    + '\\uFD50-\\uFD8F'\n    + '\\uFD92-\\uFDC7'\n    + '\\uFDF0-\\uFDFB'\n    + '\\uFE70-\\uFE74' // Arabic Pres. Forms B\n    + '\\uFE76-\\uFEFC'\n    + '\\u200C-\\u200C' // Zero-Width Non-Joiner\n    + '\\u0E01-\\u0E3A' // Thai\n    + '\\u0E40-\\u0E4E' // Hangul (Korean)\n    + '\\u1100-\\u11FF' // Hangul Jamo\n    + '\\u3130-\\u3185' // Hangul Compatibility Jamo\n    + '\\uA960-\\uA97F' // Hangul Jamo Extended-A\n    + '\\uAC00-\\uD7AF' // Hangul Syllables\n    + '\\uD7B0-\\uD7FF' // Hangul Jamo Extended-B\n    + '\\uFFA1-\\uFFDC' // Half-width Hangul\n\n  const charCode = String.fromCharCode\n\n  const cjkChars\n    = '\\u30A1-\\u30FA\\u30FC-\\u30FE' // Katakana (full-width)\n    + '\\uFF66-\\uFF9F' // Katakana (half-width)\n    + '\\uFF10-\\uFF19\\uFF21-\\uFF3A'\n    + '\\uFF41-\\uFF5A' // Latin (full-width)\n    + '\\u3041-\\u3096\\u3099-\\u309E' // Hiragana\n    + '\\u3400-\\u4DBF' // Kanji (CJK Extension A)\n    + `\\u4E00-\\u9FFF${// Kanji (Unified)\n    // Disabled as it breaks the Regex.\n    // charCode(0x20000) + '-' + charCode(0x2A6DF) + // Kanji (CJK Extension B)\n      charCode(0x2A700)\n    }-${\n      charCode(0x2B73F) // Kanji (CJK Extension C)\n    }${charCode(0x2B740)\n    }-${\n      charCode(0x2B81F) // Kanji (CJK Extension D)\n    }${charCode(0x2F800)\n    }-${\n      charCode(0x2FA1F)\n    }\\u3003\\u3005\\u303B` // Kanji (CJK supplement)\n\n  const otherChars = latinAccents + nonLatinChars + cjkChars\n\n  // equivalent of \\p{L}\n  const unicodeLetters\n    = '\\u0041-\\u005A\\u0061-\\u007A\\u00AA\\u00B5\\u00BA\\u00C0-\\u00D6\\u00D8-\\u00F6'\n    + '\\u00F8-\\u0241\\u0250-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EE\\u037A\\u0386'\n    + '\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03CE\\u03D0-\\u03F5\\u03F7-\\u0481'\n    + '\\u048A-\\u04CE\\u04D0-\\u04F9\\u0500-\\u050F\\u0531-\\u0556\\u0559\\u0561-\\u0587'\n    + '\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0621-\\u063A\\u0640-\\u064A\\u066E-\\u066F'\n    + '\\u0671-\\u06D3\\u06D5\\u06E5-\\u06E6\\u06EE-\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710'\n    + '\\u0712-\\u072F\\u074D-\\u076D\\u0780-\\u07A5\\u07B1\\u0904-\\u0939\\u093D\\u0950'\n    + '\\u0958-\\u0961\\u097D\\u0985-\\u098C\\u098F-\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0'\n    + '\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC-\\u09DD\\u09DF-\\u09E1\\u09F0-\\u09F1'\n    + '\\u0A05-\\u0A0A\\u0A0F-\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32-\\u0A33'\n    + '\\u0A35-\\u0A36\\u0A38-\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D'\n    + '\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2-\\u0AB3\\u0AB5-\\u0AB9\\u0ABD'\n    + '\\u0AD0\\u0AE0-\\u0AE1\\u0B05-\\u0B0C\\u0B0F-\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30'\n    + '\\u0B32-\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C-\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83'\n    + '\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99-\\u0B9A\\u0B9C\\u0B9E-\\u0B9F'\n    + '\\u0BA3-\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0C05-\\u0C0C\\u0C0E-\\u0C10'\n    + '\\u0C12-\\u0C28\\u0C2A-\\u0C33\\u0C35-\\u0C39\\u0C60-\\u0C61\\u0C85-\\u0C8C'\n    + '\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE'\n    + '\\u0CE0-\\u0CE1\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D28\\u0D2A-\\u0D39'\n    + '\\u0D60-\\u0D61\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6'\n    + '\\u0E01-\\u0E30\\u0E32-\\u0E33\\u0E40-\\u0E46\\u0E81-\\u0E82\\u0E84\\u0E87-\\u0E88'\n    + '\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7'\n    + '\\u0EAA-\\u0EAB\\u0EAD-\\u0EB0\\u0EB2-\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6'\n    + '\\u0EDC-\\u0EDD\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6A\\u0F88-\\u0F8B\\u1000-\\u1021'\n    + '\\u1023-\\u1027\\u1029-\\u102A\\u1050-\\u1055\\u10A0-\\u10C5\\u10D0-\\u10FA\\u10FC'\n    + '\\u1100-\\u1159\\u115F-\\u11A2\\u11A8-\\u11F9\\u1200-\\u1248\\u124A-\\u124D'\n    + '\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0'\n    + '\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310'\n    + '\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C'\n    + '\\u166F-\\u1676\\u1681-\\u169A\\u16A0-\\u16EA\\u1700-\\u170C\\u170E-\\u1711'\n    + '\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7'\n    + '\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u1900-\\u191C\\u1950-\\u196D\\u1970-\\u1974'\n    + '\\u1980-\\u19A9\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1D00-\\u1DBF\\u1E00-\\u1E9B'\n    + '\\u1EA0-\\u1EF9\\u1F00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D'\n    + '\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC'\n    + '\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC'\n    + '\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u2094\\u2102\\u2107'\n    + '\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D'\n    + '\\u212F-\\u2131\\u2133-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u2C00-\\u2C2E'\n    + '\\u2C30-\\u2C5E\\u2C80-\\u2CE4\\u2D00-\\u2D25\\u2D30-\\u2D65\\u2D6F\\u2D80-\\u2D96'\n    + '\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6'\n    + '\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u3005-\\u3006\\u3031-\\u3035'\n    + '\\u303B-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF'\n    + '\\u3105-\\u312C\\u3131-\\u318E\\u31A0-\\u31B7\\u31F0-\\u31FF\\u3400-\\u4DB5'\n    + '\\u4E00-\\u9FBB\\uA000-\\uA48C\\uA800-\\uA801\\uA803-\\uA805\\uA807-\\uA80A'\n    + '\\uA80C-\\uA822\\uAC00-\\uD7A3\\uF900-\\uFA2D\\uFA30-\\uFA6A\\uFA70-\\uFAD9'\n    + '\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C'\n    + '\\uFB3E\\uFB40-\\uFB41\\uFB43-\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F'\n    + '\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A'\n    + '\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7'\n    + '\\uFFDA-\\uFFDC'\n\n  // equivalent of \\p{Mn}\\p{Mc}\n  const unicodeAccents\n    = '\\u0300-\\u036F\\u0483-\\u0486\\u0591-\\u05B9\\u05BB-\\u05BD\\u05BF'\n    + '\\u05C1-\\u05C2\\u05C4-\\u05C5\\u05C7\\u0610-\\u0615\\u064B-\\u065E\\u0670'\n    + '\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7-\\u06E8\\u06EA-\\u06ED\\u0711\\u0730-\\u074A'\n    + '\\u07A6-\\u07B0\\u0901-\\u0903\\u093C\\u093E-\\u094D\\u0951-\\u0954\\u0962-\\u0963'\n    + '\\u0981-\\u0983\\u09BC\\u09BE-\\u09C4\\u09C7-\\u09C8\\u09CB-\\u09CD\\u09D7'\n    + '\\u09E2-\\u09E3\\u0A01-\\u0A03\\u0A3C\\u0A3E-\\u0A42\\u0A47-\\u0A48\\u0A4B-\\u0A4D'\n    + '\\u0A70-\\u0A71\\u0A81-\\u0A83\\u0ABC\\u0ABE-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD'\n    + '\\u0AE2-\\u0AE3\\u0B01-\\u0B03\\u0B3C\\u0B3E-\\u0B43\\u0B47-\\u0B48\\u0B4B-\\u0B4D'\n    + '\\u0B56-\\u0B57\\u0B82\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD7'\n    + '\\u0C01-\\u0C03\\u0C3E-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55-\\u0C56'\n    + '\\u0C82-\\u0C83\\u0CBC\\u0CBE-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5-\\u0CD6'\n    + '\\u0D02-\\u0D03\\u0D3E-\\u0D43\\u0D46-\\u0D48\\u0D4A-\\u0D4D\\u0D57\\u0D82-\\u0D83'\n    + '\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DF2-\\u0DF3\\u0E31\\u0E34-\\u0E3A'\n    + '\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EB9\\u0EBB-\\u0EBC\\u0EC8-\\u0ECD\\u0F18-\\u0F19'\n    + '\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F3F\\u0F71-\\u0F84\\u0F86-\\u0F87\\u0F90-\\u0F97'\n    + '\\u0F99-\\u0FBC\\u0FC6\\u102C-\\u1032\\u1036-\\u1039\\u1056-\\u1059\\u135F'\n    + '\\u1712-\\u1714\\u1732-\\u1734\\u1752-\\u1753\\u1772-\\u1773\\u17B6-\\u17D3\\u17DD'\n    + '\\u180B-\\u180D\\u18A9\\u1920-\\u192B\\u1930-\\u193B\\u19B0-\\u19C0\\u19C8-\\u19C9'\n    + '\\u1A17-\\u1A1B\\u1DC0-\\u1DC3\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20EB\\u302A-\\u302F'\n    + '\\u3099-\\u309A\\uA802\\uA806\\uA80B\\uA823-\\uA827\\uFB1E\\uFE00-\\uFE0F'\n    + '\\uFE20-\\uFE23'\n\n  // equivalent of \\p{Dn}\n  const unicodeDigits\n    = '\\u0030-\\u0039\\u0660-\\u0669\\u06F0-\\u06F9\\u0966-\\u096F\\u09E6-\\u09EF'\n    + '\\u0A66-\\u0A6F\\u0AE6-\\u0AEF\\u0B66-\\u0B6F\\u0BE6-\\u0BEF\\u0C66-\\u0C6F'\n    + '\\u0CE6-\\u0CEF\\u0D66-\\u0D6F\\u0E50-\\u0E59\\u0ED0-\\u0ED9\\u0F20-\\u0F29'\n    + '\\u1040-\\u1049\\u17E0-\\u17E9\\u1810-\\u1819\\u1946-\\u194F\\u19D0-\\u19D9'\n    + '\\uFF10-\\uFF19'\n  // An alpha char is a unicode chars including unicode marks or\n  // letter or char in otherChars range\n  const alpha = unicodeLetters + unicodeAccents + otherChars\n  // A numeric character is any with the number digit property, or\n  // underscore. These characters can be included in hashtags, but a hashtag\n  // cannot have only these characters.\n  const numeric = `${unicodeDigits}_`\n  // Alphanumeric char is any alpha char or a unicode char with decimal\n  // number property \\p{Nd}\n  const alphanumeric = alpha + numeric\n\n  const hashChars = '#\\\\uFF03' // normal '#' or full-width '#'\n\n  return {\n    alpha,\n    alphanumeric,\n    hashChars,\n  }\n}\n\nfunction getHashtagRegexString(): string {\n  const { alpha, alphanumeric, hashChars } = getHashtagRegexStringChars()\n\n  const hashtagAlpha = `[${alpha}]`\n  const hashtagAlphanumeric = `[${alphanumeric}]`\n  const hashtagBoundary = `^|$|[^&/${alphanumeric}]`\n  const hashCharList = `[${hashChars}]`\n\n  // A hashtag contains characters, numbers and underscores,\n  // but not all numbers.\n  const hashtag\n    = `(${\n      hashtagBoundary\n    })(${\n      hashCharList\n    })(${\n      hashtagAlphanumeric\n    }*${\n      hashtagAlpha\n    }${hashtagAlphanumeric\n    }*)`\n\n  return hashtag\n}\n\nconst REGEX = new RegExp(getHashtagRegexString(), 'i')\n\nconst editor = useLexicalComposer()\n\nonMounted(() => {\n  if (!editor.hasNodes([HashtagNode]))\n    invariant(false, 'HashtagPlugin: HashtagNode not registered on editor')\n})\n\nfunction createHashtagNode(textNode: TextNode) {\n  return $createHashtagNode(textNode.getTextContent())\n}\n\nfunction getHashtagMatch(text: string) {\n  const matchArr = REGEX.exec(text)\n  if (matchArr === null)\n    return null\n\n  const hashtagLength = matchArr[3].length + 1\n  const startOffset = matchArr.index + matchArr[1].length\n  const endOffset = startOffset + hashtagLength\n  return { end: endOffset, start: startOffset }\n}\n\nuseLexicalTextEntity<HashtagNode>(getHashtagMatch, HashtagNode, createHashtagNode)\n</script>\n\n<template />\n","import type { ElementFormatType, LexicalNode, NodeKey, SerializedLexicalNode, Spread } from 'lexical'\n\nimport { DecoratorNode } from 'lexical'\nimport type { Component } from 'vue'\n\nexport type SerializedDecoratorBlockNode = Spread<\n  {\n    format: ElementFormatType\n  },\n  SerializedLexicalNode\n>\n\nexport class DecoratorBlockNode extends DecoratorNode<Component> {\n  __format?: ElementFormatType\n\n  constructor(format?: ElementFormatType, key?: NodeKey) {\n    super(key)\n    this.__format = format || ''\n  }\n\n  exportJSON(): SerializedDecoratorBlockNode {\n    return {\n      format: this.__format || '',\n      type: 'decorator-block',\n      version: 1,\n    }\n  }\n\n  createDOM() {\n    return document.createElement('div')\n  }\n\n  updateDOM() {\n    return false\n  }\n\n  setFormat(format: ElementFormatType) {\n    const self = this.getWritable()\n    self.__format = format\n  }\n}\n\nexport function $createDecoratorBlockNode() {\n  return new DecoratorBlockNode()\n}\n\nexport function $isDecoratorBlockNode(node: LexicalNode | null | undefined): node is DecoratorBlockNode {\n  return node instanceof DecoratorBlockNode\n}\n","<script setup lang=\"ts\">\nimport type {\n  ElementFormatType,\n  NodeKey,\n} from 'lexical'\nimport {\n  $getNearestBlockElementAncestorOrThrow,\n  mergeRegister,\n} from '@lexical/utils'\nimport {\n  $getNodeByKey,\n  $getSelection,\n  $isDecoratorNode,\n  $isNodeSelection,\n  $isRangeSelection,\n  CLICK_COMMAND,\n  COMMAND_PRIORITY_LOW,\n  FORMAT_ELEMENT_COMMAND,\n  KEY_BACKSPACE_COMMAND,\n  KEY_DELETE_COMMAND,\n} from 'lexical'\nimport { ref } from 'vue'\nimport { useLexicalComposer, useLexicalNodeSelection } from '../composables'\nimport { useMounted } from '../composables/useMounted'\nimport { $isDecoratorBlockNode } from './LexicalDecoratorBlockNode'\n\nconst props = defineProps<{\n  format?: ElementFormatType\n  nodeKey: NodeKey\n  baseClass?: string\n  focusClass?: string\n}>()\n\nconst editor = useLexicalComposer()\nconst { isSelected, setSelected, clearSelection } = useLexicalNodeSelection(props.nodeKey)\nconst containerRef = ref<HTMLDivElement | null>(null)\n\nfunction onDelete(event: KeyboardEvent) {\n  if (isSelected.value && $isNodeSelection($getSelection())) {\n    event.preventDefault()\n    const node = $getNodeByKey(props.nodeKey)\n    if ($isDecoratorNode(node))\n      node?.remove()\n  }\n  return false\n}\n\nuseMounted(() => {\n  return mergeRegister(\n    editor.registerCommand<ElementFormatType>(\n      FORMAT_ELEMENT_COMMAND,\n      (formatType) => {\n        if (isSelected.value) {\n          const selection = $getSelection()\n\n          if ($isNodeSelection(selection)) {\n            const node = $getNodeByKey(props.nodeKey)\n\n            if (node && $isDecoratorBlockNode(node))\n              node.setFormat(formatType)\n          }\n          else if ($isRangeSelection(selection)) {\n            const nodes = selection.getNodes()\n\n            for (const node of nodes) {\n              if ($isDecoratorBlockNode(node)) {\n                node.setFormat(formatType)\n              }\n              else {\n                const element = $getNearestBlockElementAncestorOrThrow(node)\n                element.setFormat(formatType)\n              }\n            }\n          }\n\n          return true\n        }\n        return false\n      },\n      COMMAND_PRIORITY_LOW,\n    ),\n    editor.registerCommand<MouseEvent>(\n      CLICK_COMMAND,\n      (event) => {\n        if (event.target === containerRef.value) {\n          event.preventDefault()\n          if (!event.shiftKey)\n            clearSelection()\n\n          setSelected(!isSelected.value)\n          return true\n        }\n        return false\n      },\n      COMMAND_PRIORITY_LOW,\n    ),\n    editor.registerCommand(\n      KEY_DELETE_COMMAND,\n      onDelete,\n      COMMAND_PRIORITY_LOW,\n    ),\n    editor.registerCommand(\n      KEY_BACKSPACE_COMMAND,\n      onDelete,\n      COMMAND_PRIORITY_LOW,\n    ),\n  )\n})\n</script>\n\n<template>\n  <div\n    ref=\"containerRef\"\n    :style=\"`text-align: ${format}`\"\n    :class=\"[baseClass, isSelected ? focusClass : '']\"\n  >\n    <slot />\n  </div>\n</template>\n","<script setup lang=\"ts\">\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow strict\n */\n\nimport type { ListItemNode } from '@lexical/list'\nimport {\n  $getNearestNodeFromDOMNode,\n  $getSelection,\n  $isElementNode,\n  $isRangeSelection,\n  COMMAND_PRIORITY_LOW,\n  KEY_ARROW_DOWN_COMMAND,\n  KEY_ARROW_LEFT_COMMAND,\n  KEY_ARROW_UP_COMMAND,\n  KEY_ESCAPE_COMMAND,\n  KEY_SPACE_COMMAND,\n} from 'lexical'\nimport type { LexicalEditor } from 'lexical'\n\nimport {\n  $isListItemNode,\n  $isListNode,\n  INSERT_CHECK_LIST_COMMAND,\n  insertList,\n} from '@lexical/list'\nimport { $findMatchingParent, mergeRegister } from '@lexical/utils'\nimport { useLexicalComposer } from '../composables'\nimport { useMounted } from '../composables/useMounted'\nimport { registerClickAndPointerListeners } from '../composables/listenerManager'\n\nconst editor = useLexicalComposer()\n\nuseMounted(() => {\n  return mergeRegister(\n    editor.registerCommand(\n      INSERT_CHECK_LIST_COMMAND,\n      () => {\n        insertList(editor, 'check')\n        return true\n      },\n      COMMAND_PRIORITY_LOW,\n    ),\n    editor.registerCommand(\n      KEY_ARROW_DOWN_COMMAND,\n      (event) => {\n        return handleArrownUpOrDown(event, editor, false)\n      },\n      COMMAND_PRIORITY_LOW,\n    ),\n    editor.registerCommand(\n      KEY_ARROW_UP_COMMAND,\n      (event) => {\n        return handleArrownUpOrDown(event, editor, true)\n      },\n      COMMAND_PRIORITY_LOW,\n    ),\n    editor.registerCommand(\n      KEY_ESCAPE_COMMAND,\n      (_event) => {\n        const activeItem = getActiveCheckListItem()\n        if (activeItem != null) {\n          const rootElement = editor.getRootElement()\n          if (rootElement != null)\n            rootElement.focus()\n\n          return true\n        }\n        return false\n      },\n      COMMAND_PRIORITY_LOW,\n    ),\n    editor.registerCommand(\n      KEY_SPACE_COMMAND,\n      (event) => {\n        const activeItem = getActiveCheckListItem()\n        if (activeItem != null) {\n          editor.update(() => {\n            const listItemNode = $getNearestNodeFromDOMNode(activeItem)\n            if ($isListItemNode(listItemNode!)) {\n              event.preventDefault()\n              listItemNode.toggleChecked()\n            }\n          })\n          return true\n        }\n        return false\n      },\n      COMMAND_PRIORITY_LOW,\n    ),\n    editor.registerCommand(\n      KEY_ARROW_LEFT_COMMAND,\n      (event) => {\n        return editor.getEditorState().read(() => {\n          const selection = $getSelection()\n          if ($isRangeSelection(selection) && selection.isCollapsed()) {\n            const { anchor } = selection\n            const isElement = anchor.type === 'element'\n            if (isElement || anchor.offset === 0) {\n              const anchorNode = anchor.getNode()\n              const elementNode = $findMatchingParent(\n                anchorNode,\n                node => $isElementNode(node) && !node.isInline(),\n              )\n\n              if ($isListItemNode(elementNode)) {\n                const parent = elementNode.getParent()\n                if (\n                  $isListNode(parent)\n                  && parent.getListType() === 'check'\n                  && (isElement\n                  || elementNode.getFirstDescendant() === anchorNode)\n                ) {\n                  const domNode = editor.getElementByKey(elementNode.__key)\n\n                  if (domNode != null && document.activeElement !== domNode) {\n                    domNode.focus()\n                    event.preventDefault()\n                    return true\n                  }\n                }\n              }\n            }\n          }\n\n          return false\n        })\n      },\n      COMMAND_PRIORITY_LOW,\n    ),\n    listenPointerDown(),\n  )\n})\n\nfunction listenPointerDown() {\n  return registerClickAndPointerListeners(() => {\n    // @ts-expect-error: speculation ambiguous\n    document.addEventListener('click', handleClick)\n    document.addEventListener('pointerdown', handlePointerDown)\n  }, () => {\n    // @ts-expect-error: speculation ambiguous\n    document.removeEventListener('click', handleClick)\n    document.removeEventListener('pointerdown', handlePointerDown)\n  })\n}\n\nfunction handleCheckItemEvent(event: PointerEvent, callback: () => void) {\n  const target = event.target\n  if (!(target instanceof HTMLElement))\n    return\n\n  // Ignore clicks on LI that have nested lists\n  // @ts-expect-error: internal field\n  const firstChild: HTMLElement | null = target.firstChild\n  if (\n    firstChild != null\n    && (firstChild.tagName === 'UL' || firstChild.tagName === 'OL')\n  )\n    return\n\n  const parentNode = target.parentNode\n  // @ts-expect-error: Internal field\n  if (!parentNode || parentNode.__lexicalListType !== 'check')\n    return\n\n  const pageX = event.pageX\n  const rect = target.getBoundingClientRect()\n\n  if (\n    target.dir === 'rtl'\n      ? pageX < rect.right && pageX > rect.right - 20\n      : pageX > rect.left && pageX < rect.left + 20\n  )\n    callback()\n}\n\nfunction handleClick(event: PointerEvent) {\n  handleCheckItemEvent(event as PointerEvent, () => {\n    const domNode = event.target as HTMLElement\n    const editor = findEditor(domNode)\n\n    if (editor !== null) {\n      editor.update(() => {\n        const node = $getNearestNodeFromDOMNode(domNode)\n        if ($isListItemNode(node!)) {\n          domNode.focus()\n          node.toggleChecked()\n        }\n      })\n    }\n  })\n}\n\nfunction handlePointerDown(event: PointerEvent) {\n  handleCheckItemEvent(event, () => {\n    // Prevents caret moving when clicking on check mark\n    event.preventDefault()\n  })\n}\n\nfunction findEditor(target: Node) {\n  let node: ParentNode | Node | null = target\n\n  while (node) {\n    // @ts-expect-error internal field\n    if (node.__lexicalEditor)\n    // @ts-expect-error internal field\n      return (node.__lexicalEditor)\n\n    node = node.parentNode\n  }\n  return null\n}\n\nfunction getActiveCheckListItem(): HTMLElement | Element | null {\n  const { activeElement } = document\n  return activeElement !== null\n    && activeElement.tagName === 'LI'\n    && activeElement.parentNode !== null\n    // @ts-expect-error: internal field missing\n    && activeElement.parentNode.__lexicalListType === 'check'\n    ? activeElement\n    : null\n}\n\nfunction findCheckListItemSibling(\n  node: ListItemNode,\n  backward: boolean,\n): ListItemNode | null {\n  let sibling = backward ? node.getPreviousSibling() : node.getNextSibling()\n  let parent = node\n  // Going up in a tree to get non-null sibling\n  while (sibling == null && $isListItemNode(parent)) {\n    // Get li -> parent ul/ol -> parent li\n    parent = parent.getParentOrThrow().getParent() as ListItemNode\n    if (parent !== null) {\n      sibling = backward\n        ? parent.getPreviousSibling()\n        : parent.getNextSibling()\n    }\n  }\n\n  // Going down in a tree to get first non-nested list item\n  while ($isListItemNode(sibling!)) {\n    const firstChild = backward\n      ? sibling.getLastChild()\n      : sibling.getFirstChild()\n    if (!$isListNode(firstChild!))\n      return sibling\n\n    sibling = backward ? firstChild.getLastChild() : firstChild.getFirstChild()\n  }\n\n  return null\n}\n\nfunction handleArrownUpOrDown(\n  event: KeyboardEvent,\n  editor: LexicalEditor,\n  backward: boolean,\n) {\n  const activeItem = getActiveCheckListItem()\n\n  if (activeItem != null) {\n    editor.update(() => {\n      const listItem = $getNearestNodeFromDOMNode(activeItem)\n      if (!$isListItemNode(listItem!))\n        return\n\n      const nextListItem = findCheckListItemSibling(listItem, backward)\n      if (nextListItem != null) {\n        nextListItem.selectStart()\n        const dom = editor.getElementByKey(nextListItem.__key)\n        if (dom != null) {\n          event.preventDefault()\n          setTimeout(() => {\n            dom.focus()\n          }, 0)\n        }\n      }\n    })\n  }\n\n  return false\n}\n</script>\n\n<template />\n","let handleClickAndPointerDownListenersCount = 0\nlet handleClickAndPointerDownListenersUnregister: (() => void) | undefined\n\nexport function registerClickAndPointerListeners(register: () => void, unregister: () => void) {\n  if (handleClickAndPointerDownListenersCount++ === 0) {\n    register()\n    handleClickAndPointerDownListenersUnregister = unregister\n  }\n\n  return () => {\n    if (--handleClickAndPointerDownListenersCount === 0) {\n      handleClickAndPointerDownListenersUnregister?.()\n      handleClickAndPointerDownListenersUnregister = undefined\n    }\n  }\n}\n","<script lang=\"ts\" setup>\nimport { TRANSFORMERS, registerMarkdownShortcuts } from '@lexical/markdown'\nimport type { Transformer } from '@lexical/markdown'\nimport { useLexicalComposer } from '../composables'\nimport { useMounted } from '../composables/useMounted'\n\nconst props = withDefaults(defineProps<{\n  transformers?: Transformer[]\n}>(), {\n  transformers: () => [...TRANSFORMERS],\n})\nconst editor = useLexicalComposer()\n\nuseMounted(() => {\n  return registerMarkdownShortcuts(editor, props.transformers)\n})\n</script>\n\n<template />\n","<script setup lang=\"ts\">\nimport {\n  $getSelection,\n  $isRangeSelection,\n  COMMAND_PRIORITY_EDITOR,\n  INDENT_CONTENT_COMMAND,\n  KEY_TAB_COMMAND,\n  OUTDENT_CONTENT_COMMAND,\n} from 'lexical'\nimport { useLexicalComposer } from '../composables'\nimport { useMounted } from '../composables/useMounted'\n\nconst editor = useLexicalComposer()\n\nuseMounted(() => {\n  return editor.registerCommand<KeyboardEvent>(\n    KEY_TAB_COMMAND,\n    (event) => {\n      const selection = $getSelection()\n\n      if (!$isRangeSelection(selection))\n        return false\n\n      event.preventDefault()\n\n      return editor.dispatchCommand(\n        event.shiftKey ? OUTDENT_CONTENT_COMMAND : INDENT_CONTENT_COMMAND,\n        undefined,\n      )\n    },\n    COMMAND_PRIORITY_EDITOR,\n  )\n})\n</script>\n\n<template />\n","<script setup lang=\"ts\">\nimport type { Doc } from 'yjs'\n\nimport type { ExcludedProperties, Provider } from '@lexical/yjs'\nimport { computed, watchEffect } from 'vue'\nimport {\n  useEffect,\n  useLexicalComposer,\n  useYjsCollaboration,\n  useYjsFocusTracking,\n  useYjsHistory,\n} from '../composables'\nimport type { InitialEditorStateType } from '../types'\nimport collaborationContext from '../composables/useCollaborationContext'\n\nconst props = defineProps<{\n  id: string\n  providerFactory: (id: string, yjsDocMap: Map<string, Doc>) => Provider\n  shouldBootstrap: boolean\n  username?: string\n  cursorColor?: string\n  cursorsContainerRef?: HTMLElement | null\n  initialEditorState?: InitialEditorStateType\n  excludedProperties?: ExcludedProperties\n  // `awarenessData` parameter allows arbitrary data to be added to the awareness.\n  awarenessData?: object\n}>()\n\n// Set username and cursor color\nwatchEffect(() => {\n  if (props.username !== undefined)\n    collaborationContext.value.name = props.username\n  if (props.cursorColor !== undefined)\n    collaborationContext.value.color = props.cursorColor\n})\n\nconst editor = useLexicalComposer()\n\nuseEffect(() => {\n  collaborationContext.value.isCollabActive = true\n\n  return () => {\n    // Reseting flag only when unmount top level editor collab plugin. Nested\n    // editors (e.g. image caption) should unmount without affecting it\n    if (editor._parentEditor == null)\n      collaborationContext.value.isCollabActive = false\n  }\n})\n\nconst provider = computed(() => props.providerFactory(props.id, collaborationContext.value.yjsDocMap))\n\nconst binding = useYjsCollaboration(\n  editor,\n  props.id,\n  provider.value,\n  collaborationContext.value.yjsDocMap,\n  collaborationContext.value.name,\n  collaborationContext.value.color,\n  props.shouldBootstrap,\n  props.initialEditorState,\n  props.excludedProperties,\n  props.awarenessData,\n)\n\nwatchEffect(() => {\n  collaborationContext.value.clientID = binding.value.clientID\n})\n\nuseYjsHistory(editor, binding.value)\nuseYjsFocusTracking(\n  editor,\n  provider.value,\n  collaborationContext.value.name,\n  collaborationContext.value.color,\n  props.awarenessData,\n)\n</script>\n\n<template>\n  <Teleport :to=\"cursorsContainerRef || 'body'\">\n    <div :ref=\"(element) => binding.cursorsContainer = (element as HTMLElement | null)\" />\n  </Teleport>\n</template>\n","import { ref } from 'vue'\nimport type { Doc } from 'yjs'\n\nexport interface CollaborationContextType {\n  clientID: number\n  color: string\n  isCollabActive: boolean\n  name: string\n  yjsDocMap: Map<string, Doc>\n}\n\nconst entries = [\n  ['Cat', 'rgb(125, 50, 0)'],\n  ['Dog', 'rgb(100, 0, 0)'],\n  ['Rabbit', 'rgb(150, 0, 0)'],\n  ['Frog', 'rgb(200, 0, 0)'],\n  ['Fox', 'rgb(200, 75, 0)'],\n  ['Hedgehog', 'rgb(0, 75, 0)'],\n  ['Pigeon', 'rgb(0, 125, 0)'],\n  ['Squirrel', 'rgb(75, 100, 0)'],\n  ['Bear', 'rgb(125, 100, 0)'],\n  ['Tiger', 'rgb(0, 0, 150)'],\n  ['Leopard', 'rgb(0, 0, 200)'],\n  ['Zebra', 'rgb(0, 0, 250)'],\n  ['Wolf', 'rgb(0, 100, 150)'],\n  ['Owl', 'rgb(0, 100, 100)'],\n  ['Gull', 'rgb(100, 0, 100)'],\n  ['Squid', 'rgb(150, 0, 150)'],\n]\n\nconst randomEntry = entries[Math.floor(Math.random() * entries.length)]\n\nexport default ref<CollaborationContextType>({\n  clientID: 0,\n  color: randomEntry[1],\n  isCollabActive: false,\n  name: randomEntry[0],\n  yjsDocMap: new Map(),\n})\n","<script setup lang=\"ts\">\nimport { $isLinkNode } from '@lexical/link'\nimport { $findMatchingParent, isHTMLAnchorElement } from '@lexical/utils'\nimport {\n  $getNearestNodeFromDOMNode,\n  $getSelection,\n  $isElementNode,\n  $isRangeSelection,\n  getNearestEditorFromDOMNode,\n} from 'lexical'\nimport { useLexicalComposer, useMounted } from '../composables'\n\nconst props = withDefaults(defineProps<{\n  newTab?: boolean\n}>(), {\n  newTab: true,\n})\n\nfunction findMatchingDOM<T extends Node>(\n  startNode: Node,\n  predicate: (node: Node) => node is T,\n): T | null {\n  let node: Node | null = startNode\n  while (node != null) {\n    if (predicate(node))\n      return node\n\n    node = node.parentNode\n  }\n  return null\n}\n\nconst editor = useLexicalComposer()\n\nuseMounted(() => {\n  const onClick = (event: MouseEvent) => {\n    const target = event.target\n    if (!(target instanceof Node))\n      return\n\n    const nearestEditor = getNearestEditorFromDOMNode(target)\n\n    if (nearestEditor === null)\n      return\n\n    let url = null\n    let urlTarget = null\n    nearestEditor.update(() => {\n      const clickedNode = $getNearestNodeFromDOMNode(target)\n      if (clickedNode !== null) {\n        const maybeLinkNode = $findMatchingParent(\n          clickedNode,\n          $isElementNode,\n        )\n        if ($isLinkNode(maybeLinkNode)) {\n          url = maybeLinkNode.sanitizeUrl(maybeLinkNode.getURL())\n          urlTarget = maybeLinkNode.getTarget()\n        }\n        else {\n          const a = findMatchingDOM(target, isHTMLAnchorElement)\n          if (a !== null) {\n            url = a.href\n            urlTarget = a.target\n          }\n        }\n      }\n    })\n\n    if (url === null || url === '')\n      return\n\n    // Allow user to select link text without follwing url\n    const selection = editor.getEditorState().read($getSelection)\n    if ($isRangeSelection(selection) && !selection.isCollapsed()) {\n      event.preventDefault()\n      return\n    }\n\n    const isMiddle = event.type === 'auxclick' && event.button === 1\n    window.open(\n      url,\n      props.newTab\n      || isMiddle\n      || event.metaKey\n      || event.ctrlKey\n      || urlTarget === '_blank'\n        ? '_blank'\n        : '_self',\n    )\n    event.preventDefault()\n  }\n\n  const onMouseUp = (event: MouseEvent) => {\n    if (event.button === 1 && editor.isEditable())\n      onClick(event)\n  }\n\n  return editor.registerRootListener((rootElement, prevRootElement) => {\n    if (prevRootElement !== null) {\n      prevRootElement.removeEventListener('click', onClick)\n      prevRootElement.removeEventListener('mouseup', onMouseUp)\n    }\n    if (rootElement !== null) {\n      rootElement.addEventListener('click', onClick)\n      rootElement.addEventListener('mouseup', onMouseUp)\n    }\n  })\n})\n</script>\n\n<template />\n","<script setup lang=\"ts\" generic=\"TOption extends MenuOption\">\nimport type {\n  CommandListenerPriority,\n  TextNode,\n} from 'lexical'\nimport { onMounted, onUnmounted, ref } from 'vue'\nimport { useLexicalComposer } from '../composables'\n\nimport type { MenuOption, MenuResolution } from './LexicalMenu/shared'\nimport { useMenuAnchorRef } from './LexicalMenu/shared'\nimport LexicalMenu from './LexicalMenu/index.vue'\n\nconst props = defineProps<{\n  options: Array<TOption>\n  anchorClassName?: string\n  commandPriority?: CommandListenerPriority\n  parent?: HTMLElement\n}>()\n\nconst emit = defineEmits<{\n  (e: 'close'): void\n  (e: 'open', payload: MenuResolution): void\n  (e: 'selectOption', payload: {\n    option: TOption\n    textNodeContainingQuery: TextNode | null\n    closeMenu: () => void\n    matchingString: string\n  }): void\n}>()\nconst editor = useLexicalComposer()\nconst resolution = ref<MenuResolution | null>(null)\nconst menuRef = ref<HTMLElement | null>(null)\n\nconst anchorElementRef = useMenuAnchorRef(\n  resolution,\n  setResolution,\n  props.anchorClassName,\n  props.parent,\n)\n\nfunction setResolution(res: MenuResolution | null) {\n  resolution.value = res\n}\n\nconst PRE_PORTAL_DIV_SIZE = 1\n\nfunction closeNodeMenu() {\n  setResolution(null)\n  if (resolution.value !== null)\n    emit('close')\n}\n\nfunction openNodeMenu(res: MenuResolution) {\n  setResolution(res)\n  if (resolution.value === null)\n    emit('open', res)\n}\n\nfunction handleContextMenu(event: MouseEvent) {\n  event.preventDefault()\n  openNodeMenu({\n    getRect: () =>\n      new DOMRect(\n        event.clientX,\n        event.clientY,\n        PRE_PORTAL_DIV_SIZE,\n        PRE_PORTAL_DIV_SIZE,\n      ),\n  })\n}\n\nfunction handleClick(event: MouseEvent) {\n  if (\n    resolution.value !== null\n    && menuRef.value != null\n    && event.target != null\n    && !menuRef.value.contains(event.target as Node)\n  )\n    closeNodeMenu()\n}\n\nonMounted(() => {\n  const editorElement = editor.getRootElement()\n  if (editorElement) {\n    editorElement.addEventListener('contextmenu', handleContextMenu)\n\n    onUnmounted(() => {\n      editorElement.removeEventListener('contextmenu', handleContextMenu)\n    })\n  }\n})\n\nonMounted(() => {\n  document.addEventListener('click', handleClick)\n\n  onUnmounted(() => {\n    document.removeEventListener('click', handleClick)\n  })\n})\n</script>\n\n<template>\n  <LexicalMenu\n    :close=\"closeNodeMenu\"\n    :resolution=\"resolution!\"\n    :editor=\"editor\"\n    :anchor-element-ref=\"anchorElementRef\"\n    :options=\"options\"\n    :command-priority=\"commandPriority\"\n    @select-option=\"$emit('selectOption', $event)\"\n  >\n    <template #default=\"{ anchorElementRef: anchorRef, listItemProps }\">\n      <slot\n        v-bind=\"{\n          anchorElementRef: anchorRef,\n          listItemProps,\n          menuProps: {\n            setMenuRef: (el: HTMLElement | null) => {\n              menuRef = el\n            },\n          },\n        }\"\n      />\n    </template>\n  </LexicalMenu>\n</template>\n","import type {\n  LexicalCommand,\n  LexicalEditor,\n} from 'lexical'\nimport {\n  createCommand,\n} from 'lexical'\nimport type { Component, ComponentPublicInstance, Ref } from 'vue'\nimport { ref, watchEffect } from 'vue'\nimport { useLexicalComposer } from '../../composables'\n\nexport interface MenuTextMatch {\n  leadOffset: number\n  matchingString: string\n  replaceableString: string\n}\n\nexport interface MenuResolution {\n  match?: MenuTextMatch\n  getRect: () => DOMRect\n}\n\nexport const PUNCTUATION\n  = '\\\\.,\\\\+\\\\*\\\\?\\\\$\\\\@\\\\|#{}\\\\(\\\\)\\\\^\\\\-\\\\[\\\\]\\\\\\\\/!%\\'\"~=<>_:;'\n\nexport class MenuOption {\n  key: string\n  ref: HTMLElement | null\n\n  constructor(key: string) {\n    this.key = key\n    this.ref = null\n    this.setRefElement = this.setRefElement.bind(this)\n  }\n\n  setRefElement(el: Element | ComponentPublicInstance | null) {\n    this.ref = el as HTMLElement\n  }\n}\n\nexport type MenuRenderFn<TOption extends MenuOption> = (\n  anchorElementRef: Ref<HTMLElement | null>,\n  itemProps: {\n    selectedIndex: number | null\n    selectOptionAndCleanUp: (option: TOption) => void\n    setHighlightedIndex: (index: number) => void\n    options: Array<TOption>\n  },\n  matchingString: string | null,\n) => Component | null\n\n// Got from https://stackoverflow.com/a/42543908/2013580\nexport function getScrollParent(\n  element: HTMLElement,\n  includeHidden: boolean,\n): HTMLElement | HTMLBodyElement {\n  let style = getComputedStyle(element)\n  const excludeStaticParent = style.position === 'absolute'\n  const overflowRegex = includeHidden\n    ? /(auto|scroll|hidden)/\n    : /(auto|scroll)/\n  if (style.position === 'fixed')\n    return document.body\n\n  for (\n    let parent: HTMLElement | null = element;\n    // eslint-disable-next-line no-cond-assign\n    (parent = parent.parentElement);\n\n  ) {\n    style = getComputedStyle(parent)\n    if (excludeStaticParent && style.position === 'static')\n      continue\n\n    if (\n      overflowRegex.test(style.overflow + style.overflowY + style.overflowX)\n    )\n      return parent\n  }\n  return document.body\n}\n\nfunction isTriggerVisibleInNearestScrollContainer(\n  targetElement: HTMLElement,\n  containerElement: HTMLElement,\n): boolean {\n  const tRect = targetElement.getBoundingClientRect()\n  const cRect = containerElement.getBoundingClientRect()\n  return tRect.top > cRect.top && tRect.top < cRect.bottom\n}\n\n// Reposition the menu on scroll, window resize, and element resize.\nexport function useDynamicPositioning(\n  resolution: Ref<MenuResolution | null>,\n  targetElement: Ref<HTMLElement | null>,\n  onReposition: () => void,\n  onVisibilityChange?: (isInView: boolean) => void,\n) {\n  const editor = useLexicalComposer()\n\n  watchEffect((onInvalidate) => {\n    if (targetElement.value != null && resolution.value != null) {\n      const rootElement = editor.getRootElement()\n      const rootScrollParent\n        = rootElement != null\n          ? getScrollParent(rootElement, false)\n          : document.body\n      let ticking = false\n      let previousIsInView = isTriggerVisibleInNearestScrollContainer(\n        targetElement.value,\n        rootScrollParent,\n      )\n      const handleScroll = function () {\n        if (!ticking) {\n          window.requestAnimationFrame(() => {\n            onReposition()\n            ticking = false\n          })\n          ticking = true\n        }\n        const isInView = isTriggerVisibleInNearestScrollContainer(\n          targetElement.value!,\n          rootScrollParent,\n        )\n        if (isInView !== previousIsInView) {\n          previousIsInView = isInView\n          if (onVisibilityChange != null)\n            onVisibilityChange(isInView)\n        }\n      }\n      const resizeObserver = new ResizeObserver(onReposition)\n      window.addEventListener('resize', onReposition)\n      document.addEventListener('scroll', handleScroll, {\n        capture: true,\n        passive: true,\n      })\n      resizeObserver.observe(targetElement.value)\n      onInvalidate(() => {\n        resizeObserver.unobserve(targetElement.value!)\n        window.removeEventListener('resize', onReposition)\n        document.removeEventListener('scroll', handleScroll, true)\n      })\n    }\n  })\n}\n\nexport const SCROLL_TYPEAHEAD_OPTION_INTO_VIEW_COMMAND: LexicalCommand<{\n  index: number\n  option: MenuOption\n}> = createCommand('SCROLL_TYPEAHEAD_OPTION_INTO_VIEW_COMMAND')\n\nexport function useMenuAnchorRef(\n  resolution: Ref<MenuResolution | null>,\n  setResolution: (r: MenuResolution | null) => void,\n  className?: string,\n  parent: HTMLElement = document.body,\n): Ref<HTMLElement> {\n  const editor = useLexicalComposer()\n  const anchorElementRef = ref<HTMLElement>(document.createElement('div'))\n  const positionMenu = () => {\n    anchorElementRef.value.style.top = anchorElementRef.value.style.bottom\n    const rootElement = editor.getRootElement()\n    const containerDiv = anchorElementRef.value\n\n    const menuEle = containerDiv.firstChild as HTMLElement\n    if (rootElement !== null && resolution.value !== null) {\n      const { left, top, width, height } = resolution.value!.getRect()\n      const anchorHeight = anchorElementRef.value.offsetHeight // use to position under anchor\n      containerDiv.style.top = `${\n        top + window.scrollY + anchorHeight + 3\n      }px`\n      containerDiv.style.left = `${left + window.pageXOffset}px`\n      containerDiv.style.height = `${height}px`\n      containerDiv.style.width = `${width}px`\n      if (menuEle !== null) {\n        menuEle.style.top = `${top}`\n        const menuRect = menuEle.getBoundingClientRect()\n        const menuHeight = menuRect.height\n        const menuWidth = menuRect.width\n\n        const rootElementRect = rootElement.getBoundingClientRect()\n\n        if (left + menuWidth > rootElementRect.right) {\n          containerDiv.style.left = `${\n            rootElementRect.right - menuWidth + window.pageXOffset\n          }px`\n        }\n        if (\n          (top + menuHeight > window.innerHeight\n          || top + menuHeight > rootElementRect.bottom)\n          && top - rootElementRect.top > menuHeight\n        ) {\n          containerDiv.style.top = `${\n            top - menuHeight + window.pageYOffset - height\n          }px`\n        }\n      }\n\n      if (!containerDiv.isConnected) {\n        if (className != null)\n          containerDiv.className = className\n\n        containerDiv.setAttribute('aria-label', 'Typeahead menu')\n        containerDiv.setAttribute('id', 'typeahead-menu')\n        containerDiv.setAttribute('role', 'listbox')\n        containerDiv.style.display = 'block'\n        containerDiv.style.position = 'absolute'\n        parent.append(containerDiv)\n      }\n      anchorElementRef.value = containerDiv\n      rootElement.setAttribute('aria-controls', 'typeahead-menu')\n    }\n  }\n\n  watchEffect(() => {\n    const rootElement = editor.getRootElement()\n    if (resolution.value !== null) {\n      positionMenu()\n      return () => {\n        if (rootElement !== null)\n          rootElement.removeAttribute('aria-controls')\n\n        const containerDiv = anchorElementRef.value\n        if (containerDiv !== null && containerDiv.isConnected)\n          containerDiv.remove()\n      }\n    }\n  })\n\n  const onVisibilityChange = (isInView: boolean) => {\n    if (resolution.value !== null) {\n      if (!isInView)\n        setResolution(null)\n    }\n  }\n\n  useDynamicPositioning(\n    resolution,\n    anchorElementRef,\n    positionMenu,\n    onVisibilityChange,\n  )\n\n  return anchorElementRef\n}\n\nexport type TriggerFn = (\n  text: string,\n  editor: LexicalEditor,\n) => MenuTextMatch | null\n","<script setup lang=\"ts\" generic=\"TOption extends MenuOption\">\nimport { computed, onUnmounted, ref, watch, watchEffect } from 'vue'\nimport { $getSelection, $isRangeSelection, KEY_ARROW_DOWN_COMMAND, KEY_ARROW_UP_COMMAND, KEY_ENTER_COMMAND, KEY_ESCAPE_COMMAND, KEY_TAB_COMMAND } from 'lexical'\nimport type { CommandListenerPriority, LexicalEditor, TextNode } from 'lexical'\nimport { mergeRegister } from '@lexical/utils'\nimport { type MenuOption, type MenuResolution, type MenuTextMatch, SCROLL_TYPEAHEAD_OPTION_INTO_VIEW_COMMAND } from './shared'\n\nconst props = defineProps<{\n  close: () => void\n  editor: LexicalEditor\n  anchorElementRef: HTMLElement\n  resolution: MenuResolution\n  options: Array<TOption>\n  shouldSplitNodeWithQuery?: boolean\n  commandPriority?: CommandListenerPriority\n}>()\n\nconst emit = defineEmits<{\n  (e: 'selectOption', payload: {\n    option: TOption\n    textNodeContainingQuery: TextNode | null\n    closeMenu: () => void\n    matchingString: string\n  }): void\n}>()\n\nconst selectedIndex = ref<number | null>(null)\nconst matchString = computed(() => props.resolution.match && props.resolution.match.matchingString)\n\nfunction setHighlightedIndex(index: number | null) {\n  selectedIndex.value = index\n}\n\n/**\n * Walk backwards along user input and forward through entity title to try\n * and replace more of the user's text with entity.\n */\nfunction getFullMatchOffset(\n  documentText: string,\n  entryText: string,\n  offset: number,\n): number {\n  let triggerOffset = offset\n  for (let i = triggerOffset; i <= entryText.length; i++) {\n    if (documentText.substr(-i) === entryText.substr(0, i))\n      triggerOffset = i\n  }\n  return triggerOffset\n}\n\n/**\n * Split Lexical TextNode and return a new TextNode only containing matched text.\n * Common use cases include: removing the node, replacing with a new node.\n */\nfunction $splitNodeContainingQuery(match: MenuTextMatch): TextNode | null {\n  const selection = $getSelection()\n  if (!$isRangeSelection(selection) || !selection.isCollapsed())\n    return null\n\n  const anchor = selection.anchor\n  if (anchor.type !== 'text')\n    return null\n\n  const anchorNode = anchor.getNode()\n  if (!anchorNode.isSimpleText())\n    return null\n\n  const selectionOffset = anchor.offset\n  const textContent = anchorNode.getTextContent().slice(0, selectionOffset)\n  const characterOffset = match.replaceableString.length\n  const queryOffset = getFullMatchOffset(\n    textContent,\n    match.matchingString,\n    characterOffset,\n  )\n  const startOffset = selectionOffset - queryOffset\n  if (startOffset < 0)\n    return null\n\n  let newNode\n  if (startOffset === 0)\n    [newNode] = anchorNode.splitText(selectionOffset)\n  else\n    [, newNode] = anchorNode.splitText(startOffset, selectionOffset)\n\n  return newNode\n}\n\nwatch(matchString, () => {\n  setHighlightedIndex(0)\n}, { immediate: true })\n\nfunction selectOptionAndCleanUp(selectedEntry: TOption) {\n  props.editor.update(() => {\n    const textNodeContainingQuery\n          = props.resolution.match != null && props.shouldSplitNodeWithQuery\n            ? $splitNodeContainingQuery(props.resolution.match)\n            : null\n\n    emit('selectOption', {\n      option: selectedEntry,\n      textNodeContainingQuery,\n      closeMenu: props.close,\n      matchingString: props.resolution.match ? props.resolution.match.matchingString : '',\n    })\n  })\n}\n\nfunction updateSelectedIndex(index: number) {\n  const rootElem = props.editor.getRootElement()\n  if (rootElem !== null) {\n    rootElem.setAttribute(\n      'aria-activedescendant',\n          `typeahead-item-${index}`,\n    )\n    setHighlightedIndex(index)\n  }\n}\n\nonUnmounted(() => {\n  const rootElem = props.editor.getRootElement()\n  if (rootElem !== null)\n    rootElem.removeAttribute('aria-activedescendant')\n})\n\nwatchEffect(() => {\n  if (props.options === null)\n    setHighlightedIndex(null)\n  else if (selectedIndex.value === null)\n    updateSelectedIndex(0)\n})\n\nfunction scrollIntoViewIfNeeded(target: HTMLElement) {\n  const typeaheadContainerNode = document.getElementById('typeahead-menu')\n  if (!typeaheadContainerNode)\n    return\n\n  const typeaheadRect = typeaheadContainerNode.getBoundingClientRect()\n\n  if (typeaheadRect.top + typeaheadRect.height > window.innerHeight) {\n    typeaheadContainerNode.scrollIntoView({\n      block: 'center',\n    })\n  }\n\n  if (typeaheadRect.top < 0) {\n    typeaheadContainerNode.scrollIntoView({\n      block: 'center',\n    })\n  }\n\n  target.scrollIntoView({ block: 'nearest' })\n}\n\nwatchEffect((onInvalidate) => {\n  if (!props.commandPriority)\n    return\n\n  const fn = mergeRegister(\n    props.editor.registerCommand(\n      SCROLL_TYPEAHEAD_OPTION_INTO_VIEW_COMMAND,\n      ({ option }) => {\n        if (option.ref && option.ref != null) {\n          scrollIntoViewIfNeeded(option.ref)\n          return true\n        }\n\n        return false\n      },\n      props.commandPriority,\n    ),\n  )\n\n  onInvalidate(fn)\n})\n\nwatchEffect((onInvalidate) => {\n  if (!props.commandPriority)\n    return\n\n  const fn = mergeRegister(\n    props.editor.registerCommand<KeyboardEvent>(\n      KEY_ARROW_DOWN_COMMAND,\n      (payload) => {\n        const event = payload\n        if (props.options !== null && props.options.length && selectedIndex.value !== null) {\n          const newSelectedIndex\n                = selectedIndex.value !== props.options.length - 1 ? selectedIndex.value + 1 : 0\n          updateSelectedIndex(newSelectedIndex)\n          const option = props.options[newSelectedIndex]\n          if (option.ref != null && option.ref) {\n            props.editor.dispatchCommand(\n              SCROLL_TYPEAHEAD_OPTION_INTO_VIEW_COMMAND,\n              {\n                index: newSelectedIndex,\n                option,\n              },\n            )\n          }\n          event.preventDefault()\n          event.stopImmediatePropagation()\n        }\n        return true\n      },\n      props.commandPriority,\n    ),\n    props.editor.registerCommand<KeyboardEvent>(\n      KEY_ARROW_UP_COMMAND,\n      (payload) => {\n        const event = payload\n        if (props.options !== null && props.options.length && selectedIndex.value !== null) {\n          const newSelectedIndex\n                = selectedIndex.value !== 0 ? selectedIndex.value! - 1 : props.options.length - 1\n          updateSelectedIndex(newSelectedIndex)\n          const option = props.options[newSelectedIndex]\n          if (option.ref != null && option.ref)\n            scrollIntoViewIfNeeded(option.ref)\n\n          event.preventDefault()\n          event.stopImmediatePropagation()\n        }\n        return true\n      },\n      props.commandPriority,\n    ),\n    props.editor.registerCommand<KeyboardEvent>(\n      KEY_ESCAPE_COMMAND,\n      (payload) => {\n        const event = payload\n        event.preventDefault()\n        event.stopImmediatePropagation()\n        close()\n        return true\n      },\n      props.commandPriority,\n    ),\n    props.editor.registerCommand<KeyboardEvent>(\n      KEY_TAB_COMMAND,\n      (payload) => {\n        const event = payload\n        if (\n          props.options === null\n          || selectedIndex.value === null\n          || props.options[selectedIndex.value] == null\n        )\n          return false\n\n        event.preventDefault()\n        event.stopImmediatePropagation()\n        selectOptionAndCleanUp(props.options[selectedIndex.value])\n        return true\n      },\n      props.commandPriority,\n    ),\n    props.editor.registerCommand(\n      KEY_ENTER_COMMAND,\n      (event: KeyboardEvent | null) => {\n        if (\n          props.options === null\n          || selectedIndex.value === null\n          || props.options[selectedIndex.value] == null\n        )\n          return false\n\n        if (event !== null) {\n          event.preventDefault()\n          event.stopImmediatePropagation()\n        }\n        selectOptionAndCleanUp(props.options[selectedIndex.value])\n        return true\n      },\n      props.commandPriority,\n    ),\n  )\n\n  onInvalidate(fn)\n})\n</script>\n\n<template>\n  <slot\n    :list-item-props=\"{\n      options: props.options,\n      selectOptionAndCleanUp,\n      selectedIndex,\n      setHighlightedIndex,\n    }\"\n    :anchor-element-ref=\"anchorElementRef\"\n    :match-string=\"resolution.match ? resolution.match.matchingString : ''\"\n  />\n</template>\n","<script setup lang=\"ts\" generic=\"TOption extends MenuOption\">\nimport type {\n  CommandListenerPriority,\n  NodeKey,\n  TextNode,\n} from 'lexical'\nimport {\n  $getNodeByKey,\n} from 'lexical'\n\nimport { nextTick, ref, watch, watchEffect } from 'vue'\nimport { useLexicalComposer } from '../composables'\nimport type { MenuOption, MenuResolution } from './LexicalMenu/shared'\nimport { useMenuAnchorRef } from './LexicalMenu/shared'\nimport LexicalMenu from './LexicalMenu/index.vue'\n\nconst props = defineProps<{\n  options: Array<TOption>\n  nodeKey: NodeKey | null\n  anchorClassName?: string\n  commandPriority?: CommandListenerPriority\n  parent?: HTMLElement\n}>()\n\nconst emit = defineEmits<{\n  (e: 'close'): void\n  (e: 'open', payload: MenuResolution): void\n  (e: 'selectOption', payload: {\n    option: TOption\n    textNodeContainingQuery: TextNode | null\n    closeMenu: () => void\n    matchingString: string\n  }): void\n}>()\n\nfunction startTransition(callback: () => void) {\n  nextTick(callback)\n}\n\nconst editor = useLexicalComposer()\nconst resolution = ref<MenuResolution | null>(null)\n\nfunction setResolution(payload: MenuResolution | null) {\n  resolution.value = payload\n}\n\nconst anchorElementRef = useMenuAnchorRef(\n  resolution,\n  setResolution,\n  props.anchorClassName,\n  props.parent,\n)\n\nfunction closeNodeMenu() {\n  setResolution(null)\n  if (resolution.value !== null)\n    emit('close')\n}\n\nfunction openNodeMenu(res: MenuResolution) {\n  setResolution(res)\n  if (resolution.value === null)\n    emit('open', res)\n}\n\nfunction positionOrCloseMenu() {\n  if (props.nodeKey) {\n    editor.update(() => {\n      const node = $getNodeByKey(props.nodeKey!)\n      const domElement = editor.getElementByKey(props.nodeKey!)\n      if (node != null && domElement != null) {\n        if (resolution.value == null) {\n          startTransition(() =>\n            openNodeMenu({\n              getRect: () => domElement.getBoundingClientRect(),\n            }),\n          )\n        }\n      }\n    })\n  }\n  else if (props.nodeKey == null && resolution.value != null) {\n    closeNodeMenu()\n  }\n}\n\nwatch(() => props.nodeKey, positionOrCloseMenu, { immediate: true })\n\nwatchEffect((onInvalidate) => {\n  if (props.nodeKey != null) {\n    const fn = editor.registerUpdateListener(({ dirtyElements }) => {\n      if (dirtyElements.get(props.nodeKey!))\n        positionOrCloseMenu()\n    })\n\n    onInvalidate(fn)\n  }\n})\n</script>\n\n<template>\n  <LexicalMenu\n    v-if=\"resolution !== null && editor !== null\"\n    v-slot=\"slotProps\"\n    :resolution=\"resolution!\"\n    :editor=\"editor\"\n    :anchor-element-ref=\"anchorElementRef\"\n    :options=\"options\"\n    :command-priority=\"commandPriority\"\n    :close=\"closeNodeMenu\"\n    @select-option=\"$emit('selectOption', $event)\"\n  >\n    <slot v-bind=\"slotProps\" />\n  </LexicalMenu>\n</template>\n","<script setup lang=\"ts\" generic=\"TEmbedConfig extends EmbedConfig\">\nimport type {\n  CommandListenerPriority,\n  MutationListener,\n  NodeKey,\n  TextNode,\n} from 'lexical'\n\nimport { $isLinkNode, AutoLinkNode, LinkNode } from '@lexical/link'\n\nimport {\n  $getNodeByKey,\n  $getSelection,\n  COMMAND_PRIORITY_EDITOR,\n} from 'lexical'\n\nimport type { UnwrapRef } from 'vue'\nimport { computed, ref, watchEffect } from 'vue'\nimport { mergeRegister } from '@lexical/utils'\n\nimport { useLexicalComposer } from '../../composables'\nimport LexicalNodeMenuPlugin from '../LexicalNodeMenuPlugin.vue'\nimport type { AutoEmbedOption, EmbedConfig } from './shared'\nimport { INSERT_EMBED_COMMAND } from './shared'\n\nconst props = defineProps<{\n  embedConfigs: Array<TEmbedConfig>\n  getMenuOptions: (\n    activeEmbedConfig: TEmbedConfig,\n    embedFn: () => void,\n    dismissFn: () => void,\n  ) => Array<AutoEmbedOption>\n  menuCommandPriority?: CommandListenerPriority\n}>()\n\nconst emit = defineEmits<{\n  (e: 'openEmbedModalForConfig', embedConfig: TEmbedConfig): void\n}>()\n\nconst editor = useLexicalComposer()\nconst nodeKey = ref<NodeKey | null>(null)\nconst activeEmbedConfig = ref<TEmbedConfig | null>(null)\n\nfunction reset() {\n  nodeKey.value = null\n  activeEmbedConfig.value = null\n}\n\nfunction checkIfLinkNodeIsEmbeddable(key: NodeKey) {\n  editor.getEditorState().read(async () => {\n    const linkNode = $getNodeByKey(key)\n    if ($isLinkNode(linkNode)) {\n      for (let i = 0; i < props.embedConfigs.length; i++) {\n        const embedConfig = props.embedConfigs[i]\n\n        const urlMatch = await Promise.resolve(\n          embedConfig.parseUrl(linkNode.__url),\n        )\n\n        if (urlMatch != null) {\n          activeEmbedConfig.value = embedConfig as UnwrapRef<TEmbedConfig>\n          nodeKey.value = linkNode.getKey()\n        }\n      }\n    }\n  })\n}\n\nconst listener: MutationListener = (\n  nodeMutations,\n  { updateTags, dirtyLeaves },\n) => {\n  for (const [key, mutation] of nodeMutations) {\n    if (\n      mutation === 'created'\n      && updateTags.has('paste')\n      && dirtyLeaves.size <= 3\n    )\n      checkIfLinkNodeIsEmbeddable(key)\n    else if (key === nodeKey.value)\n      reset()\n  }\n}\n\nwatchEffect((onInvalidate) => {\n  const cleanup = mergeRegister(\n    ...[LinkNode, AutoLinkNode].map(Klass =>\n      editor.registerMutationListener(Klass, (...args) => listener(...args)),\n    ),\n  )\n\n  onInvalidate(cleanup)\n})\n\nwatchEffect((onInvalidate) => {\n  const cleanup = editor.registerCommand(\n    INSERT_EMBED_COMMAND,\n    (embedConfigType: TEmbedConfig['type']) => {\n      const embedConfig = props.embedConfigs.find(\n        ({ type }) => type === embedConfigType,\n      )\n      if (embedConfig) {\n        emit('openEmbedModalForConfig', embedConfig)\n        return true\n      }\n      return false\n    },\n    COMMAND_PRIORITY_EDITOR,\n  )\n\n  onInvalidate(cleanup)\n})\n\nasync function embedLinkViaActiveEmbedConfig() {\n  if (activeEmbedConfig.value != null && nodeKey.value != null) {\n    const linkNode = editor.getEditorState().read(() => {\n      const node = $getNodeByKey(nodeKey.value!)\n      if ($isLinkNode(node))\n        return node\n\n      return null\n    })\n\n    if ($isLinkNode(linkNode)) {\n      const result = await Promise.resolve(\n        activeEmbedConfig.value.parseUrl(linkNode.__url),\n      )\n      if (result != null) {\n        editor.update(() => {\n          if (!$getSelection())\n            linkNode.selectEnd()\n\n          activeEmbedConfig.value?.insertNode(editor, result)\n          if (linkNode.isAttached())\n            linkNode.remove()\n        })\n      }\n    }\n  }\n}\n\nconst options = computed(() => activeEmbedConfig.value != null && nodeKey.value != null\n  ? props.getMenuOptions(activeEmbedConfig.value as TEmbedConfig, embedLinkViaActiveEmbedConfig, reset)\n  : [])\n\nfunction onSelectOption({\n  option: selectedOption,\n  closeMenu,\n  textNodeContainingQuery: targetNode,\n}: {\n  option: AutoEmbedOption\n  textNodeContainingQuery: TextNode | null\n  closeMenu: () => void\n  matchingString: string\n}) {\n  editor.update(() => {\n    selectedOption.onSelect(targetNode)\n    closeMenu()\n  })\n}\n</script>\n\n<template>\n  <LexicalNodeMenuPlugin\n    v-if=\"nodeKey !== null\"\n    :node-key=\"nodeKey\"\n    :close=\"reset\"\n    :options=\"options\"\n    :command-priority=\"menuCommandPriority\"\n    @select-option=\"onSelectOption\"\n  >\n    <template #default=\"slotProps\">\n      <slot v-bind=\"slotProps\" />\n    </template>\n  </LexicalNodeMenuPlugin>\n</template>\n","import { createCommand } from 'lexical'\nimport type { LexicalCommand, LexicalEditor, LexicalNode } from 'lexical'\nimport { MenuOption } from '../LexicalMenu/shared'\n\nexport interface EmbedMatchResult<TEmbedMatchResult = unknown> {\n  url: string\n  id: string\n  data?: TEmbedMatchResult\n}\n\nexport interface EmbedConfig<\n  TEmbedMatchResultData = unknown,\n  TEmbedMatchResult = EmbedMatchResult<TEmbedMatchResultData>,\n> {\n  // Used to identify this config e.g. youtube, tweet, google-maps.\n  type: string\n  // Determine if a given URL is a match and return url data.\n  parseUrl: (\n    text: string,\n  ) => Promise<TEmbedMatchResult | null> | TEmbedMatchResult | null\n  // Create the Lexical embed node from the url data.\n  insertNode: (editor: LexicalEditor, result: TEmbedMatchResult) => void\n}\n\nexport const URL_MATCHER\n  = /((https?:\\/\\/(www\\.)?)|(www\\.))[-a-zA-Z0-9@:%._+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\\b([-a-zA-Z0-9()@:%_+.~#?&//=]*)/\n\nexport const INSERT_EMBED_COMMAND: LexicalCommand<EmbedConfig['type']>\n  = createCommand('INSERT_EMBED_COMMAND')\n\nexport class AutoEmbedOption extends MenuOption {\n  title: string\n  onSelect: (targetNode: LexicalNode | null) => void\n  constructor(\n    title: string,\n    options: {\n      onSelect: (targetNode: LexicalNode | null) => void\n    },\n  ) {\n    super(title)\n    this.title = title\n    this.onSelect = options.onSelect.bind(this)\n  }\n}\n","import type { LinkAttributes } from '@lexical/link'\nimport type { ElementNode, LexicalEditor, LexicalNode } from 'lexical'\nimport { unref, watchEffect } from 'vue'\nimport invariant from 'tiny-invariant'\n\nimport {\n  $createAutoLinkNode,\n  $isAutoLinkNode,\n  $isLinkNode,\n  AutoLinkNode,\n} from '@lexical/link'\nimport { mergeRegister } from '@lexical/utils'\nimport {\n  $createTextNode,\n  $isElementNode,\n  $isLineBreakNode,\n  $isTextNode,\n  TextNode,\n} from 'lexical'\nimport type { MaybeRef } from 'vue'\n\ntype ChangeHandler = (url: string | null, prevUrl: string | null) => void\n\ninterface LinkMatcherResult {\n  attributes?: LinkAttributes\n  index: number\n  length: number\n  text: string\n  url: string\n}\n\nexport type LinkMatcher = (text: string) => LinkMatcherResult | null\n\nfunction findFirstMatch(\n  text: string,\n  matchers: Array<LinkMatcher>,\n): LinkMatcherResult | null {\n  for (let i = 0; i < matchers.length; i++) {\n    const match = matchers[i](text)\n\n    if (match)\n      return match\n  }\n\n  return null\n}\n\nconst PUNCTUATION_OR_SPACE = /[.,;\\s]/\n\nfunction isSeparator(char: string): boolean {\n  return PUNCTUATION_OR_SPACE.test(char)\n}\n\nfunction endsWithSeparator(textContent: string): boolean {\n  return isSeparator(textContent[textContent.length - 1])\n}\n\nfunction startsWithSeparator(textContent: string): boolean {\n  return isSeparator(textContent[0])\n}\n\nfunction isPreviousNodeValid(node: LexicalNode): boolean {\n  let previousNode = node.getPreviousSibling()\n  if ($isElementNode(previousNode))\n    previousNode = previousNode.getLastDescendant()\n\n  return (\n    previousNode === null\n    || $isLineBreakNode(previousNode)\n    || ($isTextNode(previousNode)\n    && endsWithSeparator(previousNode.getTextContent()))\n  )\n}\n\nfunction isNextNodeValid(node: LexicalNode): boolean {\n  let nextNode = node.getNextSibling()\n  if ($isElementNode(nextNode))\n    nextNode = nextNode.getFirstDescendant()\n\n  return (\n    nextNode === null\n    || $isLineBreakNode(nextNode)\n    || ($isTextNode(nextNode) && startsWithSeparator(nextNode.getTextContent()))\n  )\n}\n\nfunction isContentAroundIsValid(\n  matchStart: number,\n  matchEnd: number,\n  text: string,\n  node: TextNode,\n): boolean {\n  const contentBeforeIsValid\n    = matchStart > 0\n      ? isSeparator(text[matchStart - 1])\n      : isPreviousNodeValid(node)\n  if (!contentBeforeIsValid)\n    return false\n\n  const contentAfterIsValid\n    = matchEnd < text.length\n      ? isSeparator(text[matchEnd])\n      : isNextNodeValid(node)\n  return contentAfterIsValid\n}\n\nfunction handleLinkCreation(\n  node: TextNode,\n  matchers: Array<LinkMatcher>,\n  onChange: ChangeHandler,\n): void {\n  const nodeText = node.getTextContent()\n  let text = nodeText\n  let invalidMatchEnd = 0\n  let remainingTextNode = node\n  let match\n\n  // eslint-disable-next-line no-cond-assign\n  while ((match = findFirstMatch(text, matchers)) && match !== null) {\n    const matchStart = match.index\n    const matchLength = match.length\n    const matchEnd = matchStart + matchLength\n    const isValid = isContentAroundIsValid(\n      invalidMatchEnd + matchStart,\n      invalidMatchEnd + matchEnd,\n      nodeText,\n      node,\n    )\n\n    if (isValid) {\n      let linkTextNode\n      if (invalidMatchEnd + matchStart === 0) {\n        [linkTextNode, remainingTextNode] = remainingTextNode.splitText(\n          invalidMatchEnd + matchLength,\n        )\n      }\n      else {\n        [, linkTextNode, remainingTextNode] = remainingTextNode.splitText(\n          invalidMatchEnd + matchStart,\n          invalidMatchEnd + matchStart + matchLength,\n        )\n      }\n      const linkNode = $createAutoLinkNode(match.url, match.attributes)\n      const textNode = $createTextNode(match.text)\n      textNode.setFormat(linkTextNode.getFormat())\n      textNode.setDetail(linkTextNode.getDetail())\n      linkNode.append(textNode)\n      linkTextNode.replace(linkNode)\n      onChange(match.url, null)\n      invalidMatchEnd = 0\n    }\n    else {\n      invalidMatchEnd += matchEnd\n    }\n\n    text = text.substring(matchEnd)\n  }\n}\n\nfunction handleLinkEdit(\n  linkNode: AutoLinkNode,\n  matchers: Array<LinkMatcher>,\n  onChange: ChangeHandler,\n): void {\n  // Check children are simple text\n  const children = linkNode.getChildren()\n  const childrenLength = children.length\n  for (let i = 0; i < childrenLength; i++) {\n    const child = children[i]\n    if (!$isTextNode(child) || !child.isSimpleText()) {\n      replaceWithChildren(linkNode)\n      onChange(null, linkNode.getURL())\n      return\n    }\n  }\n\n  // Check text content fully matches\n  const text = linkNode.getTextContent()\n  const match = findFirstMatch(text, matchers)\n  if (match === null || match.text !== text) {\n    replaceWithChildren(linkNode)\n    onChange(null, linkNode.getURL())\n    return\n  }\n\n  // Check neighbors\n  if (!isPreviousNodeValid(linkNode) || !isNextNodeValid(linkNode)) {\n    replaceWithChildren(linkNode)\n    onChange(null, linkNode.getURL())\n    return\n  }\n\n  const url = linkNode.getURL()\n  if (url !== match.url) {\n    linkNode.setURL(match.url)\n    onChange(match.url, url)\n  }\n\n  if (match.attributes) {\n    const rel = linkNode.getRel()\n    if (rel !== match.attributes.rel) {\n      linkNode.setRel(match.attributes.rel || null)\n      onChange(match.attributes.rel || null, rel)\n    }\n\n    const target = linkNode.getTarget()\n    if (target !== match.attributes.target) {\n      linkNode.setTarget(match.attributes.target || null)\n      onChange(match.attributes.target || null, target)\n    }\n  }\n}\n\n// Bad neighbours are edits in neighbor nodes that make AutoLinks incompatible.\n// Given the creation preconditions, these can only be simple text nodes.\nfunction handleBadNeighbors(textNode: TextNode, onChange: ChangeHandler): void {\n  const previousSibling = textNode.getPreviousSibling()\n  const nextSibling = textNode.getNextSibling()\n  const text = textNode.getTextContent()\n\n  if ($isAutoLinkNode(previousSibling) && !startsWithSeparator(text)) {\n    replaceWithChildren(previousSibling)\n    onChange(null, previousSibling.getURL())\n  }\n\n  if ($isAutoLinkNode(nextSibling) && !endsWithSeparator(text)) {\n    replaceWithChildren(nextSibling)\n    onChange(null, nextSibling.getURL())\n  }\n}\n\nfunction replaceWithChildren(node: ElementNode): Array<LexicalNode> {\n  const children = node.getChildren()\n  const childrenLength = children.length\n\n  for (let j = childrenLength - 1; j >= 0; j--)\n    node.insertAfter(children[j])\n\n  node.remove()\n  return children.map(child => child.getLatest())\n}\n\nexport function useAutoLink(\n  editor: LexicalEditor,\n  matchers: MaybeRef<Array<LinkMatcher>>,\n  onChange?: ChangeHandler,\n) {\n  watchEffect((onInvalidate) => {\n    if (!editor.hasNodes([AutoLinkNode]))\n      invariant(false, 'LexicalAutoLinkPlugin: AutoLinkNode not registered on editor')\n\n    const onChangeWrapped = (url: string | null, prevUrl: string | null) => {\n      if (onChange)\n        onChange(url, prevUrl)\n    }\n\n    const fn = mergeRegister(\n      editor.registerNodeTransform(TextNode, (textNode: TextNode) => {\n        const parent = textNode.getParentOrThrow()\n        if ($isAutoLinkNode(parent)) {\n          handleLinkEdit(parent, unref(matchers), onChangeWrapped)\n        }\n        else if (!$isLinkNode(parent)) {\n          if (textNode.isSimpleText())\n            handleLinkCreation(textNode, unref(matchers), onChangeWrapped)\n\n          handleBadNeighbors(textNode, onChangeWrapped)\n        }\n      }),\n\n      editor.registerNodeTransform(AutoLinkNode, (linkNode: AutoLinkNode) => {\n        handleLinkEdit(linkNode, unref(matchers), onChangeWrapped)\n      }),\n    )\n\n    onInvalidate(fn)\n  })\n}\n","<script setup lang=\"ts\">\nimport { useLexicalComposer } from '../../composables'\nimport { type LinkMatcher, useAutoLink } from './shared'\n\nconst props = defineProps<{\n  matchers: LinkMatcher[]\n}>()\n\nconst emit = defineEmits<{\n  (e: 'change', value: { url: string | null, prevUrl: string | null }): void\n}>()\n\nconst editor = useLexicalComposer()\n\nuseAutoLink(editor, props.matchers, (url: string | null, prevUrl: string | null) => {\n  emit('change', {\n    url,\n    prevUrl,\n  })\n})\n</script>\n\n<template />\n","<script setup lang=\"ts\" generic=\"TOption extends MenuOption\">\nimport type { LexicalEditor, RangeSelection, TextNode } from 'lexical'\nimport { $getSelection, $isRangeSelection, $isTextNode, COMMAND_PRIORITY_LOW } from 'lexical'\nimport { ref, watchEffect } from 'vue'\nimport { useLexicalComposer } from '../../composables'\nimport type { MenuOption, MenuResolution } from '../LexicalMenu/shared'\nimport { useMenuAnchorRef } from '../LexicalMenu/shared'\nimport LexicalMenu from '../LexicalMenu/index.vue'\nimport type { TypeaheadMenuPluginProps } from './shared'\n\nconst props = withDefaults(defineProps<TypeaheadMenuPluginProps<TOption>>(), {\n  commandPriority: COMMAND_PRIORITY_LOW,\n})\n\nconst emit = defineEmits<{\n  (e: 'close'): void\n  (e: 'open', payload: MenuResolution): void\n  (e: 'queryChange', payload: string | null): void\n  (e: 'selectOption', payload: {\n    option: TOption\n    textNodeContainingQuery: TextNode | null\n    closeMenu: () => void\n    matchingString: string\n  }): void\n}>()\n\nconst editor = useLexicalComposer()\nconst resolution = ref<MenuResolution | null>(null)\n\nfunction setResolution(payload: MenuResolution | null) {\n  resolution.value = payload\n}\n\nconst anchorElementRef = useMenuAnchorRef(\n  resolution,\n  setResolution,\n  props.anchorClassName,\n  props.parent,\n)\n\nfunction closeTypeahead() {\n  setResolution(null)\n  if (resolution.value !== null)\n    emit('close')\n}\n\nfunction openTypeahead(res: MenuResolution) {\n  setResolution(res)\n  if (resolution.value === null)\n    emit('open', res)\n}\n\nfunction getTextUpToAnchor(selection: RangeSelection): string | null {\n  const anchor = selection.anchor\n  if (anchor.type !== 'text')\n    return null\n\n  const anchorNode = anchor.getNode()\n  if (!anchorNode.isSimpleText())\n    return null\n\n  const anchorOffset = anchor.offset\n  return anchorNode.getTextContent().slice(0, anchorOffset)\n}\n\nfunction tryToPositionRange(\n  leadOffset: number,\n  range: Range,\n  editorWindow: Window,\n): boolean {\n  const domSelection = editorWindow.getSelection()\n  if (domSelection === null || !domSelection.isCollapsed)\n    return false\n\n  const anchorNode = domSelection.anchorNode\n  const startOffset = leadOffset\n  const endOffset = domSelection.anchorOffset\n\n  if (anchorNode == null || endOffset == null)\n    return false\n\n  try {\n    range.setStart(anchorNode, startOffset)\n    range.setEnd(anchorNode, endOffset)\n  }\n  catch (error) {\n    return false\n  }\n\n  return true\n}\n\nfunction getQueryTextForSearch(editor: LexicalEditor): string | null {\n  let text = null\n  editor.getEditorState().read(() => {\n    const selection = $getSelection()\n    if (!$isRangeSelection(selection))\n      return\n\n    text = getTextUpToAnchor(selection)\n  })\n  return text\n}\n\nfunction isSelectionOnEntityBoundary(\n  editor: LexicalEditor,\n  offset: number,\n): boolean {\n  if (offset !== 0)\n    return false\n\n  return editor.getEditorState().read(() => {\n    const selection = $getSelection()\n    if ($isRangeSelection(selection)) {\n      const anchor = selection.anchor\n      const anchorNode = anchor.getNode()\n      const prevSibling = anchorNode.getPreviousSibling()\n      return $isTextNode(prevSibling) && prevSibling.isTextEntity()\n    }\n    return false\n  })\n}\n\nwatchEffect((onInvalidate) => {\n  const updateListener = () => {\n    editor.getEditorState().read(() => {\n      const editorWindow = editor._window || window\n      const range = editorWindow.document.createRange()\n      const selection = $getSelection()\n      const text = getQueryTextForSearch(editor)\n\n      if (\n        !$isRangeSelection(selection)\n        || !selection.isCollapsed()\n        || text === null\n        || range === null\n      ) {\n        closeTypeahead()\n        return\n      }\n\n      const match = props.triggerFn(text, editor)\n      emit('queryChange', match ? match.matchingString : null)\n\n      if (\n        match !== null\n        && !isSelectionOnEntityBoundary(editor, match.leadOffset)\n      ) {\n        const isRangePositioned = tryToPositionRange(\n          match.leadOffset,\n          range,\n          editorWindow,\n        )\n        if (isRangePositioned !== null) {\n          openTypeahead({\n            getRect: () => range.getBoundingClientRect(),\n            match,\n          })\n          return\n        }\n      }\n      closeTypeahead()\n    })\n  }\n\n  const removeUpdateListener = editor.registerUpdateListener(updateListener)\n\n  onInvalidate(removeUpdateListener)\n})\n</script>\n\n<template>\n  <LexicalMenu\n    v-if=\"resolution !== null && editor !== null\"\n    :anchor-element-ref=\"anchorElementRef\"\n    :editor=\"editor\"\n    :resolution=\"resolution!\"\n    :options=\"options\"\n    should-split-node-with-query\n    :command-priority=\"commandPriority\"\n    :close=\"closeTypeahead\"\n    @select-option=\"$emit('selectOption', $event)\"\n  >\n    <template #default=\"slotProps\">\n      <slot v-bind=\"slotProps\" />\n    </template>\n  </LexicalMenu>\n</template>\n","import type {\n  CommandListenerPriority,\n  LexicalCommand,\n} from 'lexical'\nimport {\n  createCommand,\n} from 'lexical'\n\nimport type {\n  MenuOption,\n  MenuRenderFn,\n  MenuResolution,\n  MenuTextMatch,\n  TriggerFn,\n} from '../LexicalMenu/shared'\n\nexport const PUNCTUATION\n  = '\\\\.,\\\\+\\\\*\\\\?\\\\$\\\\@\\\\|#{}\\\\(\\\\)\\\\^\\\\-\\\\[\\\\]\\\\\\\\/!%\\'\"~=<>_:;'\n\n// Got from https://stackoverflow.com/a/42543908/2013580\nexport function getScrollParent(\n  element: HTMLElement,\n  includeHidden: boolean,\n): HTMLElement | HTMLBodyElement {\n  let style = getComputedStyle(element)\n  const excludeStaticParent = style.position === 'absolute'\n  const overflowRegex = includeHidden\n    ? /(auto|scroll|hidden)/\n    : /(auto|scroll)/\n  if (style.position === 'fixed')\n    return document.body\n\n  for (\n    let parent: HTMLElement | null = element;\n    // eslint-disable-next-line no-cond-assign\n    (parent = parent.parentElement);\n\n  ) {\n    style = getComputedStyle(parent)\n    if (excludeStaticParent && style.position === 'static')\n      continue\n\n    if (\n      overflowRegex.test(style.overflow + style.overflowY + style.overflowX)\n    )\n      return parent\n  }\n  return document.body\n}\n\nexport { useDynamicPositioning } from '../LexicalMenu/shared'\n\nexport const SCROLL_TYPEAHEAD_OPTION_INTO_VIEW_COMMAND: LexicalCommand<{\n  index: number\n  option: MenuOption\n}> = createCommand('SCROLL_TYPEAHEAD_OPTION_INTO_VIEW_COMMAND')\n\nexport function useBasicTypeaheadTriggerMatch(\n  trigger: string,\n  { minLength = 1, maxLength = 75 }: { minLength?: number, maxLength?: number },\n): TriggerFn {\n  return (text: string) => {\n    const validChars = `[^${trigger}${PUNCTUATION}\\\\s]`\n    const TypeaheadTriggerRegex = new RegExp(\n      `(^|\\\\s|\\\\()(`\n      + `[${\n        trigger\n        }]`\n        + `((?:${\n        validChars\n        }){0,${\n        maxLength\n        }})`\n        + `)$`,\n    )\n    const match = TypeaheadTriggerRegex.exec(text)\n    if (match !== null) {\n      const maybeLeadingWhitespace = match[1]\n      const matchingString = match[3]\n      if (matchingString.length >= minLength) {\n        return {\n          leadOffset: match.index + maybeLeadingWhitespace.length,\n          matchingString,\n          replaceableString: match[2],\n        }\n      }\n    }\n    return null\n  }\n}\n\nexport interface TypeaheadMenuPluginProps<TOption extends MenuOption> {\n  options: Array<TOption>\n  triggerFn: TriggerFn\n  anchorClassName?: string\n  commandPriority?: CommandListenerPriority\n  parent?: HTMLElement\n}\n\nexport { MenuOption, MenuRenderFn, MenuResolution, MenuTextMatch, TriggerFn }\n"],"mappings":"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","names":["MenuOption","import_vue","import_text","import_utils","invariant","import_vue","import_vue","import_tiny_invariant","invariant","import_vue","import_vue","import_text","import_lexical","import_vue","import_text","import_utils","import_utils","import_lexical","import_utils","import_dragon","import_utils","import_vue","import_utils","import_lexical","import_yjs","import_vue","import_lexical","import_vue","import_vue","import_vue","import_vue","import_lexical","initializeEditor","editor","import_vue","import_lexical","import_utils","import_lexical","import_vue","editor","commandsLog","import_vue","import_link","import_lexical","import_tiny_invariant","import_utils","invariant","import_table","import_utils","import_lexical","import_tiny_invariant","invariant","import_lexical","import_vue","import_vue","import_lexical","import_vue","import_tiny_invariant","invariant","import_lexical","import_utils","import_lexical","import_vue","import_lexical","import_list","import_utils","editor","import_lexical","import_vue","import_vue","import_link","import_utils","import_lexical","import_vue","import_lexical","import_vue","MenuOption","import_vue","import_lexical","import_utils","import_lexical","import_vue","import_link","import_lexical","import_vue","import_utils","import_lexical","MenuOption","import_vue","import_tiny_invariant","import_link","import_utils","import_lexical","invariant","import_lexical","import_vue","editor","import_lexical","SCROLL_TYPEAHEAD_OPTION_INTO_VIEW_COMMAND"]}